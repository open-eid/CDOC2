{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is documentation for the CDOC2 System and includes analysis, protocol and format specification, architecture documentation.</p>"},{"location":"#goal","title":"Goal","text":"<p>This documentation aims to describe the CDOC2 System.</p>"},{"location":"#document-scope","title":"Document scope","text":"<p>The specification describes:</p> <ul> <li>Supported encryption schemes.</li> <li>Abstract and serialized data format.</li> <li>Details of cryptographic operations.</li> <li>Use of a CDOC2 capsule server.</li> <li>Implementation guidelines.</li> </ul>"},{"location":"#terms-and-acronyms","title":"Terms and acronyms","text":"<ul> <li> <p><code>CDOC</code> - Crypto Digidoc, encrypted file transmission format used in the Estonian eID ecosystem</p> </li> <li> <p><code>CDOC 1.0</code> - Unofficial term for all (XML-ENC based) CDOC formats preceding this specification.</p> </li> <li> <p><code>CDOC2 System</code> - IT system, which allows users to send encrypted files to each other with the help of CDOC2 Client Applications and CDOC2 Capsule Servers</p> </li> <li> <p><code>CDOC2 Container</code> - File format for transmitting the encrypted payload and metadata information, including the capsule from Sender to Recipient</p> </li> <li> <p><code>Capsule</code> - Data structure, which contains encryption scheme-specific information (encrypted symmetric keys, public keys, salt, server object references, ...)which Recipient can use to derive, establish or retrieve decryption keys for decrypting the CDOC2 Container. Capsule can either be a Server Capsule or a Container Capsule.</p> </li> <li> <p><code>Server Capsule</code> - A Capsule that is mediated by a CDOC2 Capsule Server.</p> </li> <li> <p><code>Container Capsule</code> - A Capsule that is created inside a CDOC2 container and is therefore not sent to a CDOC2 Capsule Server.</p> </li> <li> <p><code>CCS</code> - CDOC2 Capsule Server</p> </li> <li> <p><code>SID/MID proxy</code> - Proxy provided by RIA to provide access to Smart-ID RP API and Mobile-ID REST API</p> </li> <li> <p><code>hardware security token</code> - Smart-card (for example Estonian eID ID-card) or FIDO authenticator with asymmetric cryptographic keys</p> </li> <li> <p><code>ECDH</code> - Elliptic-curve Diffie\u2013Hellman. Key-agreement protocol that allows two parties, each having an EC public\u2013private key pair, to establish a shared secret over an insecure channel.</p> </li> <li> <p><code>AEAD</code> - Authenticated Encryption with Additional Data</p> </li> <li> <p><code>ECC</code> - Elliptic-Curve Cryptography</p> </li> <li> <p><code>ECC DH</code> - Elliptic-Curve Cryptography Diffie Hellman key-establishment algorithm</p> </li> <li> <p><code>ECC CDH</code> - Elliptic-Curve Cryptography Co-factor Diffie Hellman key-establishment algorithm</p> </li> <li> <p><code>HMAC</code> - Hash-Based Message Authentication Code. Protects integrity of CDOC2 Container.</p> </li> </ul> <ul> <li> <p><code>CEK</code> - Content Encryption Key. Symmetric key used to encrypt the payload of CDOC2 Container.</p> </li> <li> <p><code>KEK</code> - Key Encryption Key. Symmetric key used to encrypt (wrap) the FMK, so that FMK could be transmitted inside CDOC2 Container to Recipient.</p> </li> <li> <p><code>FMK</code> - File Master Key. Cryptographic key material for deriving other encryption and HMAC keys.</p> </li> <li> <p><code>CC</code> - CDOC2 Capsule. Data structure inside CDOC2 Container. CC contains information for decrypting the payload of CDOC2 Container.  That information could be a symmetric cryptographic key, a share of symmetric cryptographic key,  or necessary data for establishing such key with key derivation algorithm or key-agreement protocol, for example, with ECDH.</p> </li> <li> <p><code>HHK</code> - Header HMAC Key</p> </li> </ul>"},{"location":"#short-overview","title":"Short overview","text":"<p>The document is divided into five parts \u2013 the first part describes the functionality of the CDOC 2.0 Client Application and the CDOC2 Capsule Server as use case models. The second part defines the CDOC2 protocol and data formats. The third, respectively, defines the system architecture in terms of system components and interfaces. Following those parts is a test plan. The final part of the document is various user guides.</p> <p></p>"},{"location":"01_use_case_model/ch03_use_cases/","title":"CDOC2 Client Application Use Case Model","text":"<p>CDOC2 Client Application is an abstract component in the CDOC2 System. CDOC2 Client Applications help users to encrypt files to CDOC2 Container, decrypt received CDOC2 Containers. Specific examples of CDOC2 Client Applications include:</p> <ul> <li>DigiDoc4 desktop application for Windows, MacOS and Linux operating systems (https://open-eid.github.io/#desktop-applications, https://www.id.ee/en/rubriik/digidoc4-client/, https://github.com/open-eid/DigiDoc4-Client)</li> <li>DigiDoc4 mobile application for Android and IOS operating systems (https://open-eid.github.io/#mobile-applications)</li> <li>CDOC2 Client CLI Application</li> </ul> <p>Use cases specified here are written in a generic form, so that they are applicable to all client applications. Client applications will implement specified use cases and their documentation may include additional information (use case models, UX wireframes, ...) about the implemented functions. Use cases specified here are written in a generic form, so that they are applicable to all client applications. Client applications will implement specified use cases and their documentation may include additional information (use case models, UX wireframes, ...) about the implemented functions.</p>"},{"location":"01_use_case_model/ch03_use_cases/#actors","title":"Actors","text":""},{"location":"01_use_case_model/ch03_use_cases/#human-actors","title":"Human actors","text":"User Person, who is using CDOC2 Client Applications for sending encrypted files to somebody else (then as a Sender), or decrypting received CDOC2 Containers (then as a Recipient). In some use cases, the User may encrypt files with symmetric encryption key or password, store the CDOC2 Container for themselves and later decrypt the CDOC2 Container by themselves. Sender User, who wishes to send encrypted files, which are packaged into a CDOC2 Container, to one or multiple Recipients Recipient User, who wishes to decrypt the received CDOC2 Container and has control over necessary cryptographic key material Administrator Person, who is managing CDOC2 Client Application for Users and is creating the configuration data for them"},{"location":"01_use_case_model/ch03_use_cases/#system-components-as-actors","title":"System components as actors","text":"CDOC2 Client Application (Client) Desktop or mobile application, which encrypts or decrypts CDOC2 Containers and is used by Users CDOC2 Capsule Server (CCS) CCS mediates CDOC2 Server Capsules between Sender and Recipient. Sender's Client can upload a Server Capsule to one or multiple CCS servers. Recipient's Client can download Server Capsule from CCS server after authentication. CDOC2 Shares Server (CSS) CDOC2 Shares Server mediates Key Shares between Sender and Recipient. Sender's Client splits Shares Capsule into multiple Key Shares and each Key Share is uploaded into a single Shares Server. Recipient's Client can download Shares Capsule from Shares Servers after authentication. Capsule Data structure, which contains encryption scheme-specific information (encrypted symmetric keys, public keys, salt, server object references, ...)which Recipient can use to derive, establish or retrieve decryption keys for decrypting the CDOC2 Container. Capsule can either be a Server Capsule or a Container Capsule. Server Capsule A Capsule that is mediated by a CDOC2 Capsule Server. Container Capsule A Capsule that is created inside a CDOC2 container and is therefore not sent to a CDOC2 Capsule Server. Shares Capsule Encryption/decryption key material which is split into Key Shares in order to distribute it to multiple CSS servers. Key Share A share of Shares Capsule that on its own provides no knowledge of the key value. Sometimes called a cryptographic key component or key split. Key Shares are always distributed among different Shares Servers and depending on the encryption scheme, all or a certain number of shares are needed to construct the original key value. LDAP-server An application used for publishing public keys."},{"location":"01_use_case_model/ch03_use_cases/#use-cases-for-recipients-with-hardware-security-tokens","title":"Use cases for Recipients with hardware security tokens","text":"<p>These use cases are useful, when Sender knows that Recipient has specific hardware security token, and knows the public key certificate which correspond to the asymmetric cryptographic key pair on that security token. CC, which can be decrypted only with Recipient's security token, may be transmitted alongside with the CDOC2 Container itself with the encrypted payload, or with the help of CCS server.</p>"},{"location":"01_use_case_model/ch03_use_cases/#ucclient01-encrypt-cdoc2-container-for-sending-to-recipient-with-a-security-token","title":"UC.Client.01 \u2014 Encrypt CDOC2 container for sending to Recipient with a security token","text":"Use Case Context CDOC2 Client Application adds Sender's chosen files into the CDOC2 container and encrypts the container with CEK. CEK is encrypted with KEK, which is generated with key-agreement protocol between Sender and Recipient. Scope CDOC2 Client Application (Client) Use Case Level User goal Primary Actor Sender Preconditions Client has a long-term access token from CDOC2 authentication server. <p>Success Guarantees</p> <ul> <li>CDOC2 container is saved into file system.</li> <li>A server capsule is sent for each Recipient to the CDOC2 capsule server.</li> <li>Client has received a transaction code for each server capsule.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Sender chooses files to be included in CDOC2 container and specifies the target filename and path for CDOC2 container.</li> <li>Sender enters identifiers for each Recipient.</li> <li>Client creates a capsule for each Recipient.</li> <li>Client displays a list of Capsule Servers to Sender.</li> <li>Sender chooses a CDOC2 Capsule Server.</li> <li>Client creates a TLS-connection with the chosen CDOC2 Capsule Server and receives the server's certificate.</li> <li>Client verifies the server's certificate against the configuration.</li> <li>Client forwards each Recipient's server capsule to the chosen CDOC2 Capsule Server. Client provides a server capsule expiration time from internal application configuration for each capsule. If a Recipient's certificate expiration time is earlier, it uses the certificate expiration time for that Recipient's capsule. Client receives a transaction code for each server capsule.</li> <li>Client creates a container into file system in the chosen target path and adds a header.</li> <li>Client verifies that the header does not exceed the size limit defined by the specification.</li> <li>Client verifies technical file correctness and file name safety rules according to the specification. Client creates an archive, compresses it, encrypts the compressed archive with CEK and adds it to the container as payload.</li> <li>Client saves the CDOC2 container and displays Sender a notification.</li> </ol> <p>Extensions</p> <p>1a. Sender chose to encrypt from the Windows Explorer / MacOS Finder / Linux folder explorer context dialog: \"Encrypt with eID\" and \"Encrypt with password\":</p> <ol> <li>Client asks Sender for the container target name and path.</li> <li>Sender specifies the target name and path.</li> <li>Use case continues from step 2.</li> </ol> <p>2a. Client chooses to search for Recipient information in LDAP directory:</p> <ol> <li>Sender inserts Recipient personal code.</li> <li>Client requests corresponding certificates and displays those.</li> <li>Sender chooses certificate(s).</li> <li>Use case continues from step 2.</li> </ol> <p>2b. Certificate is not readable or is not in proper format:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>5a. Configuration has no CDOC2 capsule servers:</p> <ol> <li>Client creates a container in the target path and adds a header with container capsules for each recipient.</li> <li>Use case continues from step 11.</li> </ol> <p>5b. Configuration has a default CDOC2 capsule server:</p> <ol> <li>Use case continues from step 7.</li> </ol> <p>6a. Sender chooses to not use the CDOC2 capsule server:</p> <ol> <li>Client creates a container in the target path and adds a header with container capsules for each recipient.</li> <li>Use case continues from step 11.</li> </ol> <p>7a. TLS connection cannot be established:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case continues from step 5.</li> </ol> <p>8a. Certificate validation against the configuration fails:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case continues from step 5.</li> </ol> <p>8b. Client uses an organization-specific external configuration service:</p> <ol> <li>Client first syncs default capsule expiration time from an organization-specific external service.</li> <li>External configuration service provides a default capsule expiration time.</li> <li>Client sends a server capsule using the appropriate API service to a CCS using the expiration time from external configuration or when a Recipient's certificate expiration time is earlier, it uses the certificate expiration time for that Recipient's capsule. Client receives a transaction code for each server capsule.</li> <li>Use case continues from step 9.</li> </ol> <p>8c. The expiration time provided by Client is longer than allowed in the CCS system configuration:</p> <ol> <li>CCS returns Client an error message.</li> <li>Client notifies Sender.</li> <li>Use case ends.</li> </ol> <p>9a. Forwarding capsules to a CDOC2 capsule server fails:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>9b. CDOC2 capsule server does not return a transaction identifier for each server capsule:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>10a. Header size is larger than allowed by the specification:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>11a. Files are not correct:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#ucclient02-decrypt-cdoc2-container-with-a-security-token","title":"UC.Client.02 \u2014 Decrypt CDOC2 Container with a security token","text":"Use Case Context CDOC2 Client Application (Client) decrypts the archive in the CDOC2 container provided by Recipient, using a server capsule from either CDOC2 Capsule Server or a container capsule from inside the container. <p>Scope CDOC2 Client Application</p> Use Case Level User goal Primary Actor Recipient <p>Preconditions</p> <ul> <li>Recipient's security token is connected.</li> <li>Client has a long-term access token from CDOC2 authentication server.</li> </ul> <p>Success Guarantees</p> <ul> <li>Files from the CDOC2 container are decrypted.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Recipient chooses the CDOC2 Container to be decrypted and specifies the target filename and path for the files.</li> <li>Client verifies that the header does not exceed the size limit defined by the specification.</li> <li>Client reads Recipient certificate from the security token.</li> <li>Client verifies that the container has a record of the Recipient.</li> <li>Client verifies that the Recipient record has a CDOC2 Capsule Server reference.</li> <li>Client uses Recipient's eID means to authenticate to CCS.</li> <li>Client sends the CDOC2 Capsule Server the transaction code from the container.</li> <li>Client receives a capsule from the CDOC2 Capsule Server.</li> <li>Client decrypts the encrypted archive in the CDOC2 container using the connected security token.</li> <li>Continues with UC.Client.P.04 \u2014 Re-encrypt existing CDOC2 container for long-term storage.</li> </ol> <p>Extensions 2a. Header size is larger than allowed by the specification:</p> <ol> <li>Client displays Recipient a notification.</li> <li>Use case ends.</li> </ol> <p>3a. Reading certificate from the security token fails.</p> <ol> <li>Client displays Recipient a notification.</li> <li>Use case ends.</li> </ol> <p>4a. Recipient record not found in the container.</p> <ol> <li>Client displays Recipient a notification.</li> <li>Use case ends.</li> </ol> <p>5a. Recipient record does not contain a reference to a CDOC2 Capsule Server.</p> <ol> <li>Client finds a container capsule from the Recipient record.</li> <li>Use case continues from step 9.</li> </ol> <p>6a. PIN 1 code is required:</p> <ol> <li>Client asks user for a PIN 1 code.</li> <li>Recipient enters the PIN code.</li> <li>Client completes the authentication. Use case continues from step 7.</li> </ol> <p>6b. Authentication fails:</p> <ol> <li>Client displays user a notification.</li> <li>Use case ends.</li> </ol> <p>8a. No capsule returned from CDOC2 Capsule Server:</p> <ol> <li>Client displays user a notification.</li> <li>Use case ends.</li> </ol> <p>9a. Decryption of the content encryption key fails:</p> <ol> <li>Client displays user a notification.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#use-cases-for-password-based-encryption","title":"Use cases for password-based encryption","text":"<p>These use cases are useful when User wishes to protect confidential files by encrypting them with CEK generated from regular password. User may then store CDOC2 Container for longer period, without worrying that security token may not be usable, or public key certificate might be revoked or expired. CDOC2 Container may be later decrypted by Sender itself or Recipient, who knows the shared password.</p> <p>This group of UCs also include a special use case, when Recipient re-encrypts the content from received Container with a password.</p>"},{"location":"01_use_case_model/ch03_use_cases/#ucclientp01-encrypt-cdoc2-container-with-password-for-long-term-storage","title":"UC.Client.P.01 \u2014 Encrypt CDOC2 container with password for long-term storage","text":"Use Case Context Encrypt local files for long-term storage using CDOC2 Client Application and password-based cryptography by creating a new CDOC2 Container. This use case is useful for occasions where decryption does not depend on availability of security tokens. Scope CDOC2 Client Application (Client) Use Case Level User goal Primary Actor User <p>Success Guarantees</p> <ul> <li>A new CDOC2 container is created and it can be decrypted with the user's password.</li> </ul> <p>Main Success Scenario</p> <ol> <li>User chooses the files that are to be encrypted.</li> <li>Client asks User to specify the target name and path.</li> <li>User specifies a target name and path in local file system.</li> <li>User enters a password to be used for password-based cryptography and a password hint (short one-line text) to be displayed during decryption.</li> <li>Client verifies that the password satisfies minimal requirements.</li> <li>Client creates a container into file system in the chosen target path and adds a header.</li> <li>Client verifies that the header does not exceed the size limit defined by the specification.</li> <li>Client verifies technical file correctness, creates an archive, compresses it and encrypts the compressed archive.</li> <li>Client saves the CDOC2 container and displays Sender a notification.</li> </ol> <p>Extensions</p> <p>1a. Sender chose to encrypt from the Windows Explorer / MacOS Finder / Linux folder explorer context dialog: \"Encrypt with eID\" and \"Encrypt with password\":</p> <ol> <li>Client asks Sender for the container target name and path.</li> <li>Sender specifies the target name and path.</li> <li>Use case continues from step 2.</li> </ol> <p>5a. Password does not meet minimum requirements:</p> <ol> <li>Client notifies the User with instructions to insert a new password.</li> <li>Use case continues from step 4.</li> </ol> <p>6a. Container creation fails:</p> <ol> <li>System notifies the User.</li> <li>Use case ends.</li> </ol> <p>7a. Header size is larger than allowed by the specification:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>8a. Files are not correct:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>9a. Container saving fails:</p> <ol> <li>Client notifies the User.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#ucclientp02-decrypt-cdoc2-container-with-password","title":"UC.Client.P.02 \u2014 Decrypt CDOC2 container with password","text":"Use Case Context CDOC2 Client Application decrypts CDOC2 Container with password-based cryptography. Scope CDOC2 Client Application (Client) Use Case Level User goal Primary Actor User, Recipient <p>Main Success Scenario</p> <ol> <li>User specifies which CDOC2 container they wish to open.</li> <li>Client opens the container and retrieves the header information. Client verifies that the header does not exceed the limit defined in the specification.</li> <li>Client asks User for the password to decrypt the container. Client shows a password hint based on the <code>KeyLabel</code> value set during encryption.</li> <li>User enters the password.</li> <li>Client verifies the password and decrypts the CDOC2 container.</li> <li>Client asks user for the target location where to save the files.</li> <li>User defines the target location.</li> <li>Client unpacks the archive contents and saves it to the target location.</li> </ol> <p>Extensions</p> <p>2a. Header exceed the length limit according to the specification:</p> <ol> <li>Client notifies the user.</li> <li>Use case ends.</li> </ol> <p>5a. Password is not correct:</p> <ol> <li>Client notifies the user.</li> <li>Use case continues from step 3.</li> </ol> <p>8a. Saving archive contents to disk fails:</p> <ol> <li>Client notifies the user.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#ucclientp04-re-encrypt-existing-cdoc2-container-for-long-term-storage","title":"UC.Client.P.04 \u2014 Re-encrypt existing CDOC2 container for long-term storage","text":"Use Case Context CDOC2 Client Application offers Recipient to re-encrypt all files after CDOC2 container decryption and before extracting and saving files locally. Scope CDOC2 Client Application (Client) Use Case Level User goal Primary Actor User, in a Recipient role <p>Preconditions</p> <ul> <li>CDOC2 container was just decrypted.</li> </ul> <p>Success Guarantees</p> <ul> <li>Files are re-encrypted.</li> <li>The re-encrypted container is saved locally.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Client suggests Recipient to re-encrypt the decrypted container contents and displays multiple options for encryption.</li> <li>Recipient chooses to re-encrypt and chooses to encrypt with a password.</li> <li>Client asks Recipient to specify the target name and path.</li> <li>Recipient specifies a target name and path in local file system.</li> <li>Recipient enters a password to be used for password-based cryptography.</li> <li>Client verifies that the password satisfies minimal requirements.</li> <li>Client adds the files to an archive and creates a new CDOC2 container, which it saves to the target location.</li> <li>Client notifies the Recipient.</li> </ol> <p>Extensions</p> <p>2a. Recipient chooses to re-encrypt using a security token:</p> <ol> <li>Client verifies that the security token is connected.</li> <li>Recipient specifies a target name and path in local file system and enters the security token password.</li> <li>Client verifies the password. If password is not correct, the use case continues from the previous step.</li> <li>Use case continues from step 7.</li> </ol> <p>5a. Password does not meet minimum requirements.</p> <ol> <li>Client notifies the Recipient with instructions to insert a new password.</li> <li>Use case continues from step 3.</li> </ol> <p>7a. Container creation or saving fails.</p> <ol> <li>System notifies the Recipient.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#use-cases-supporting-recipients-authenticating-to-multiple-cdoc2-shares-servers","title":"Use cases supporting Recipients authenticating to multiple CDOC2 Shares Servers","text":"<p>These use cases are useful, when Sender knows that Recipient can use eID means that support authentication. These allow Sender to divide the key material into shares according to a secret-sharing scheme and distribute those among multiple independent CDOC2 Shares Servers (CSS). Recipient would need to authenticate to CSS servers and download all the shares in order to reconstruct the KEK from those.</p>"},{"location":"01_use_case_model/ch03_use_cases/#ucclient03-encrypt-cdoc2-container-using-key-shares","title":"UC.Client.03 \u2014 Encrypt CDOC2 container using key shares","text":"Use Case Context CDOC2 Client Application adds Sender's chosen files into the CDOC2 container and encrypts the container with CEK. CEK is encrypted with KEK. KEK is generated by Sender's Client and then divided into Key Shares. Each share is uploaded to different CDOC2 Shares Server.  Scope CDOC2 Client Application (Client) Use Case Level User goal Primary Actor Sender <p>Success Guarantees</p> <ul> <li>CDOC2 container is saved into file system.</li> <li>For each server capsule a share is sent to each CDOC2 Shares Server.</li> <li>Client has received a share identifier for each Shares Capsule share.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Sender chooses files to be included in CDOC2 container and specifies the target filename and path for CDOC2 container.</li> <li>Sender enters identifiers for each Recipient. </li> <li>Client creates a capsule for each Recipient.</li> <li>Client splits the capsules by creating a share for each CSS. </li> <li>Client creates a TLS-connection with each CSS and receives the server certificates.</li> <li>Client verifies the server certificates against the configuration.</li> <li>Client forwards a share per Recipient together with their natural person identifier to each of the CDOC2 Shares Servers. Client provides a shares capsule expiration time from internal application configuration for each capsule share. Client receives a share identifier for each shares capsule share.</li> <li>Client creates a container into file system in the chosen target path and adds a header.</li> <li>Client verifies that the header does not exceed the size limit defined by the specification.</li> <li>Client verifies technical file correctness and file name safety rules according to the specification. Client creates an archive, compresses it, encrypts the compressed archive with CEK and adds it to the container as payload.</li> <li>Client saves the CDOC2 container and displays Sender a notification.</li> </ol> <p>Extensions</p> <p>1a. Sender chose to encrypt from the Windows Explorer / MacOS Finder / Linux folder explorer context dialog: \"Encrypt with eID\":</p> <ol> <li>Client asks Sender for the container target name and path.</li> <li>Sender specifies the target name and path.</li> <li>Use case continues from step 2.</li> </ol> <p>5a. TLS connection cannot be established:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>6a. Certificate validation against the configuration fails:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>6b. Client uses an organization-specific external configuration service:</p> <ol> <li>Client first syncs default capsule expiration time from an organization-specific external service.</li> <li>External configuration service provides a default capsule expiration time.</li> <li>Client sends a shares capsule share to CSS API service using the expiration time from external configuration. Client receives a share identifier for each shares capsule share.</li> <li>Use case continues from step 9.</li> </ol> <p>6c. The expiration time provided by Client is longer than allowed in the CSS system configuration:</p> <ol> <li>CSS returns Client an error message.</li> <li>Client notifies Sender.</li> <li>Use case ends.</li> </ol> <p>7a. Sending capsules to a CDOC2 Shares Server fails:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>7b. CDOC2 Shares Server does not return a share identifier for each shares capsule share:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>8a. Header size is larger than allowed by the specification:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol> <p>9a. Files are not correct:</p> <ol> <li>Client displays Sender a notification.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#ucclient04-decrypt-cdoc2-container-using-multiserver-authentication","title":"UC.Client.04 \u2014 Decrypt CDOC2 container using multiserver authentication","text":"Use Case Context CDOC2 Client Application (Client) decrypts the archive in the CDOC2 container provided by Recipient, using a shares capsule constructed from shares obtained from multiple CDOC2 Shares Servers. <p>Scope CDOC2 Client Application</p> Use Case Level User goal Primary Actor Recipient <p>Preconditions</p> <ul> <li>The CDOC2 container has been encrypted using Shares Capsule shares and supports authentication-based decryption. </li> </ul> <p>Success Guarantees</p> <ul> <li>Files from the CDOC2 container are decrypted.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Recipient chooses the CDOC2 Container to be decrypted and specifies the target filename and path for the files.</li> <li>Client verifies that the header does not exceed the size limit defined by the specification.</li> <li>Recipient enters their personal identification number and chooses an eID authentication method.</li> <li>Client finds Capsule Share matching to recipient identification number. Client reads share identifiers and their matching Shares Server URLs from Capsule Share and requests a nonce for each share identifier. </li> <li>Client uses share identifier, Share Server URL and the nonce of each Key Share to generate an AuthenticationToken.</li> <li>Client shows Recipient an authentication form with input options specific to the authentication service (e.g., phone number input field, QR code scanning option). The Recipient initiates authentication using one of the options.</li> <li>Client initiates AuthenticationToken signing with authentication service.</li> <li>Recipient completes the authentication using their eID means which also creates a signature on the authentication hash with authentication key pair.</li> <li>Client reads Recipient certificate from the authentication response.</li> <li>Client verifies that the container has a Recipient record with the same Recipient ID.</li> <li>Client constructs a Share specific authentication ticket and uses it to authenticate itself to download the data of a Key Share.</li> <li>Client receives data for all Key Shares.</li> <li>Client combines the shares into a full secret and derives the KEK. Client uses the key material to decrypt the encrypted archive in the CDOC2 container and calculate HMAC to validate the integrity of the container.</li> <li>Continues with UC.Client.P.04 \u2014 Re-encrypt existing CDOC2 container for long-term storage.</li> </ol> <p>Extensions 2a. Header size is larger than allowed by the specification:</p> <ol> <li>Client displays Recipient a notification.</li> <li>Use case ends.</li> </ol> <p>8a. Authentication is not successful:</p> <ol> <li>Client notifies the user and offers to try again.</li> <li>Use case continues from step 6.</li> </ol> <p>10a. A Recipient record does not exist with the same personal identification number:</p> <ol> <li>Client displays Recipient a notification.</li> <li>Use case ends.</li> </ol> <p>11a. Authentication validation fails:</p> <ol> <li>Client displays Recipient a notification.</li> <li>Use case ends.</li> </ol> <p>12a. Client does not receive shares from each CSS because a request timed out:</p> <ol> <li>Client displays user a notification and instructs trying again.</li> <li>Use case continues from step 3.</li> </ol> <p>12a. Client does not receive shares from each CSS because a share is missing or expired:</p> <ol> <li>Client displays user a notification that the container cannot be decrypted anymore.</li> <li>Use case ends.</li> </ol> <p>13a. Decryption or HMAC validation fails:</p> <ol> <li>Client displays user a notification that the container is corrupted.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#cdoc2-server-use-case-model","title":"CDOC2 Server Use Case Model","text":""},{"location":"01_use_case_model/ch03_use_cases/#use-cases-where-cdoc2-capsule-servers-hold-the-whole-server-capsule","title":"Use cases where CDOC2 Capsule Servers hold the whole Server Capsule","text":"<p>These use cases are useful, when Sender knows that Recipient has specific hardware security token, and knows the public key certificate which correspond to the asymmetric cryptographic key pair on that security token. Server Capsule, which can be decrypted only with Recipient's security token, is stored on a single CCS server and must be accessed from there. CCS server enables expiration of access to these capsules.</p>"},{"location":"01_use_case_model/ch03_use_cases/#uckts01-forward-capsules","title":"UC.KTS.01 Forward Capsules","text":"Context of Use CDOC2 Client Application forwards Server Capsules to CDOC2 Capsule Server (CCS). Server Capsules contain a content encryption key encrypted for a particular Recipient, which is used for decrypting the archive in a CDOC2 container. Server Capsule is saved with an expiration time and a unique share identifier is created and returned to the CDOC2 Client Application. <p>Scope CDOC2 Capsule Server (CCS)</p> Use Case Level User goal Primary Actor CDOC2 Client Application (Client) <p>Success Guarantees</p> <ul> <li>Server Capsules are saved with an expiration time.</li> <li>Share identifiers are forwarded to the CDOC2 Client Application.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Client sends a server capsule using the appropriate API service to a CCS. Client provides a server capsule expiration time from internal application configuration for each capsule. If a Recipient's certificate expiration time is earlier, it uses the certificate expiration time for that Recipient's capsule.</li> <li>CCS validates the server capsules against specification rules.</li> <li>CCS generates a universally unique share identifier (UUID).</li> <li>CCS saves the server capsule, validates the expiration time provided by Client based on its system configuration settings and sets the expiration time of the capsules.</li> <li>CCS returns Client a share identifier for each capsule.</li> </ol> <p>Extensions 1a. Client uses an organization-specific external configuration service:</p> <ol> <li>Client first syncs default capsule expiration time from an organization-specific external service.</li> <li>External provides a default capsule expiration time.</li> <li>Client sends a server capsule using the appropriate API service to a CCS using the expiration time from external configuration or when a Recipient's certificate expiration time is earlier, it uses the certificate expiration time for that Recipient's capsule.</li> <li>Use case continues from step 2.</li> </ol> <p>2a. Server capsule exceeds the allowed length limit:</p> <ol> <li>CCS returns Client an error message.</li> <li>Use case ends.</li> </ol> <p>4a. Client did not provide an expiration time:</p> <ol> <li>CCS calculates the expiration time based on system configuration.</li> <li>Use case continues from step 5.</li> </ol> <p>4b. The expiration time provided by Client is longer than allowed in the CCS system configuration:</p> <ol> <li>CCS returns Client an error message.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#uckts02-request-capsule","title":"UC.KTS.02 Request Capsule","text":"Context of Use CDOC2 Client Application requests a Server Capsule from CDOC2 Capsule Server. Server Capsule contains an encrypted content encryption key, used for decrypting the archive in a CDOC2 container. The Server Capsule is identified by public key in Recipient certificate and the share identifier provided by CDOC2 Client Application. <p>Scope CDOC2 Capsule Server (CCS)</p> Use Case Level User goal Primary Actor CDOC2 Client Application (Client) <p>Preconditions</p> <ul> <li>Recipient is authenticated (see UC.KTS.04 Authenticate Recipient).</li> </ul> <p>Success guarantees</p> <ul> <li>Server Capsule is forwarded to CDOC2 Client Application.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Client requests a Server Capsule using the appropriate API service, providing a share identifier as input.</li> <li>CCS validates the share identifier against specification rules.</li> <li>CCS finds the correct Server Capsule using the share identifier and validates that the Recipient public key matches with the one in the Capsule.</li> <li>CCS sends the Client the Capsule.</li> </ol> <p>Extensions 2a. Share identifier is too long:</p> <ol> <li>CCS returns Client an error message.</li> <li>Use case ends.</li> </ol> <p>3a. Capsule was not found:</p> <ol> <li>CCS returns Client an error message.</li> <li>Use case ends.</li> </ol> <p>3b. Recipient public key does not match the one in the Capsule:</p> <ol> <li>CCS returns Client an error message.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#uckts03-delete-server-capsules","title":"UC.KTS.03 Delete Server Capsules","text":"Context of Use System timer deletes expired Server Capsules. <p>Scope CDOC2 Capsule Server (CCS)</p> Use Case Level User goal Primary Actor CDOC2 Client Application (Client) <p>Success guarantees</p> <ul> <li>Expired Server Capsules are removed from the storing CCS.</li> </ul> <p>Trigger</p> <ul> <li>System timer schedules and initiates the deletion of expired Server Capsules.</li> </ul> <p>Main Success Scenario</p> <ol> <li>CCS identifies expired Server Capsules.</li> <li>CCS deletes expired Server Capsules.</li> </ol> <p>Extensions</p> <p>1a. No expired Server Capsules found.</p> <ol> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#uckts04-authenticate-recipient","title":"UC.KTS.04 Authenticate Recipient","text":"Context of Use CDOC2 Client Application (Client) establishes a TLS-connection to CDOC2 Capsule Server and forwards Recipient certificate. <p>Scope CDOC2 Capsule Server (CCS)</p> Use Case Level Subfunction Primary Actor CDOC2 Client Application (Client) Preconditions Client has a long-term access token from CDOC2 authentication server. <p>Success guarantees</p> <ul> <li>TLS-connection is established.</li> <li>Recipient certificate exists and is received.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Client initiates a TLS-connection and forwards Recipient certificate.</li> <li>CCS verifies certificate validity using an OCSP service.</li> <li>CCS establishes the TLS connection.</li> </ol> <p>Extensions</p> <p>2a. Recipient certificate is not valid:</p> <ol> <li>CCS replies to the Client with an error message.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#use-cases-with-multiple-cdoc2-shares-servers-holding-shares-of-capsules","title":"Use cases with multiple CDOC2 Shares Servers holding shares of capsules","text":"<p>These use cases are useful, when Sender knows that Recipient can use some eID means for authenticating themselves, but cannot use eID means that support encryption/decryption. These allow Sender to divide the key material into shares according to a secret-sharing scheme and distribute those among multiple independent CSS-s. Recipient would need to authenticate to CSS servers and download all the shares in order to reconstruct the KEK from those.</p>"},{"location":"01_use_case_model/ch03_use_cases/#uckts06-forward-capsule-shares","title":"UC.KTS.06 Forward Capsule Shares","text":"Context of Use CDOC2 Client Application forwards shares of all Shares Capsules to CDOC2 Shares Servers (CSS). This use case assumes the n-of-n encryption scheme where the number of shares per capsule is equal to the number of receiving CSS servers. All shares have to be combined in order to construct a capsule that contains a content encryption key (CEK) encrypted for a particular Recipient. Shares Capsule shares are saved with an expiration time and a unique share identifier is created and returned to the CDOC2 Client Application from each CSS. <p>Scope CDOC2 Shares Server (CSS)</p> Use Case Level User goal Primary Actor CDOC2 Client Application (Client) <p>Success Guarantees</p> <ul> <li>Shares of all Shares Capsules are saved with Recipient natural person identifier and an expiration time to all receiving CSS servers.</li> <li>Share identifiers are forwarded to the CDOC2 Client Application.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Client sends shares of each Shares Capsule to appropriate CSS servers using an API service. Shares are matched to CSS servers by server IDs. Client provides a natural person identifier corresponding to the Recipient. Client provides a shares capsule expiration time from internal application configuration for each capsule share. </li> <li>Each CSS validates the shares capsule shares against specification rules.</li> <li>Each CSS generates a share identifier.</li> <li>Each CSS saves the shares capsule share.</li> <li>Each CSS returns Client a share identifier for each capsule.</li> </ol> <p>Extensions 1a. Client uses an organization-specific external configuration service:</p> <ol> <li>Client first syncs default capsule expiration time from an organization-specific external service.</li> <li>External provides a default capsule expiration time.</li> <li>Client sends a shares capsule share using the appropriate API service to all CSS-s.</li> <li>Use case continues from step 2.</li> </ol> <p>2a. Shares capsule exceeds the allowed length limit:</p> <ol> <li>CSS returns Client an error message.</li> <li>Use case ends.</li> </ol>"},{"location":"01_use_case_model/ch03_use_cases/#uckts07-request-capsule-shares","title":"UC.KTS.07 Request Capsule Shares","text":"Context of Use CDOC2 Client Application requests Shares Capsule shares from all CDOC2 Shares Servers. The Shares Capsule share is identified by the share identifier provided by CDOC2 Client Application, the CSS server ID and the Recipient identification (ETSI semantics identifier) that can be matched to Recipient public certificate. <p>Scope CDOC2 Shares Server (CSS)</p> Use Case Level User goal Primary Actor CDOC2 Client Application (Client) <p>Success guarantees</p> <ul> <li>Recipient is authenticated.</li> <li>Shares Capsule shares from all CDOC2 Shares Servers are forwarded to CDOC2 Client Application.</li> </ul> <p>Main Success Scenario</p> <ol> <li>Client requests a nonce from each CSS API service, providing the share identifier as input.</li> <li>Client calculates an authentication hash.</li> <li>Client asks the Recipient to authenticate. </li> <li>Recipient signs the authentication token and Client receives Recipient certificate that matches the Recipient identification used in the accessed Shares Capsule.</li> <li>Client constructs server-specific authentication tickets and sends one to each CSS.</li> <li>Each CSS validates the received authentication ticket, which includes validating the ticket type, nonce, signature, key pair and public keys.</li> <li>CSS returns the Shares Capsule share. </li> </ol> <p>Extensions</p> <p>1a. Capsule share was not found:</p> <ol> <li>CSS returns Client an error message.</li> <li>Use case ends.</li> </ol> <p>3a. Client is unable to get the Recipient to sign an authentication hash:</p> <ol> <li>Use case ends.</li> </ol> <p>6a. Validation by a CSS finds an error:</p> <ol> <li>CSS returns Client an error message.</li> <li>Use case ends.</li> </ol>"},{"location":"02_protocol_and_cryptography_spec/appendix_a_header_fbs/","title":"Appendix A: header.fbs","text":"<pre><code>include \"recipients.fbs\";\n\nnamespace ee.cyber.cdoc2.fbs.header;\n\n// Union for communicating the recipient type\nunion Capsule {\n    recipients.ECCPublicKeyCapsule,\n    recipients.RSAPublicKeyCapsule,\n    recipients.KeyServerCapsule,\n    recipients.SymmetricKeyCapsule,\n    recipients.PBKDF2Capsule\n}\n\n// FMK encryption method enum.\nenum FMKEncryptionMethod:byte {\n    UNKNOWN,\n    XOR\n}\n\n// Payload encryption method enum.\nenum PayloadEncryptionMethod:byte {\n    UNKNOWN,\n    CHACHA20POLY1305\n}\n\n// Intermediate record, some languages act very poorly when it comes\n// to an array of unions.\n// Thus it is better to have an an array of tables that\n// contains the union as a field.\ntable RecipientRecord {\n    capsule:                Capsule;\n    key_label:              string (required);\n    encrypted_fmk:          [ubyte] (required);\n    fmk_encryption_method:  FMKEncryptionMethod = UNKNOWN;\n}\n\n// Header structure.\ntable Header {\n    recipients:                [RecipientRecord];\n\n    payload_encryption_method: PayloadEncryptionMethod = UNKNOWN;\n}\n\nroot_type Header;\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/appendix_b_recipients_fbs/","title":"Appendix B: recipients.fbs","text":"<pre><code>namespace ee.cyber.cdoc2.fbs.recipients;\n\n//server recipient type\nunion KeyDetailsUnion {\n    EccKeyDetails, RsaKeyDetails\n}\n\n// Elliptic curve type enum for ECCPublicKey recipient\nenum EllipticCurve:byte {\n    UNKNOWN,\n    secp384r1\n}\n\n// KDF algorithm identifier enum\nenum KDFAlgorithmIdentifier:byte {\n    UNKNOWN,\n    PBKDF2WithHmacSHA256\n}\n\ntable RsaKeyDetails {\n    //RSA pub key in DER - RFC8017 RSA Public Key Syntax (A.1.1) https://www.rfc-editor.org/rfc/rfc8017#page-54\n    recipient_public_key:   [ubyte] (required);\n}\n\ntable EccKeyDetails {\n    // Elliptic curve type enum\n    curve:                 EllipticCurve = UNKNOWN;\n\n    //EC pub key in TLS 1.3 format https://datatracker.ietf.org/doc/html/rfc8446#section-4.2.8.2\n    //for secp384r1 curve: 0x04 + X 48 coord bytes + Y coord 48 bytes)\n    recipient_public_key:  [ubyte] (required);\n}\n\n// ECC public key recipient\ntable ECCPublicKeyCapsule {\n    curve:                 EllipticCurve = UNKNOWN;\n    recipient_public_key:  [ubyte] (required);\n    sender_public_key:     [ubyte] (required);\n}\n\ntable RSAPublicKeyCapsule {\n    recipient_public_key:  [ubyte] (required);\n    encrypted_kek:         [ubyte] (required);\n}\n\n// recipient where ephemeral key material is download from server (server scenarios)\ntable KeyServerCapsule {\n    // recipient id - key type specific. For public key cryptography this is usually recipient public key\n    recipient_key_details: KeyDetailsUnion;\n    keyserver_id:          string (required);\n    transaction_id:        string (required);\n}\n\n// symmetric long term crypto\ntable SymmetricKeyCapsule {\n    salt:                 [ubyte] (required);\n}\n\n// password derived key\ntable PBKDF2Capsule {\n    // HKDF salt to derive KEK\n    salt:                     [ubyte] (required);\n    password_salt:            [ubyte] (required);\n    kdf_algorithm_identifier: KDFAlgorithmIdentifier = UNKNOWN;\n    kdf_iterations:           int32;\n}\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/appendix_c_cdoc2-capsules/","title":"Appendix C: Key Capsules API, version 2.0 of cdoc2services API","text":"<pre><code>openapi: 3.0.3\ninfo:\ncontact:\n    url: http://cyber.ee\ntitle: cdoc2-key-capsules\nversion: '2.0'\ndescription: API for exchanging CDOC2 ephemeral key material in capsules\nservers:\n- url: 'https://cdoc2-keyserver-01.test.riaint.ee:8443'\n    description: RIA test TLS\n- url: 'https://cdoc2-keyserver-01.test.riaint.ee:8444'\n    description: RIA test mutualTLS\n\npaths:\n'/key-capsules/{transactionId}':\n    get:\n    summary: Get capsule for transactionId\n    description: Get capsule for transactionId\n    tags:\n        - cdoc2-key-capsules\n    parameters:\n        - name: transactionId\n        in: path\n        schema:\n            type: string\n            minLength: 18\n            maxLength: 34\n        required: true\n        description: transaction id from recipients.KeyServerCapsule.transaction_id (fbs)\n    responses:\n        '200':\n        description: OK\n        content:\n            application/json:\n            schema:\n                $ref: '#/components/schemas/Capsule'\n        '400':\n        description: 'Bad request. Client error.'\n        '401':\n        description: 'Unauthorized. Client certificate was not presented with the request.'\n        '404':\n        description: 'Not Found. 404 is also returned, when recipient id in record does not match with public key in client certificate.'\n    operationId: getCapsuleByTransactionId\n    security:\n        - mutualTLS: []\n'/key-capsules':\n    post:\n    summary: Add Capsule\n    description: Save Capsule and generate transaction id using secure random. Generated transactionId is returned in Location header\n    operationId: createCapsule\n    responses:\n        '201':\n        description: Created\n        headers:\n            Location:\n            schema:\n                type: string\n                example: /key-capsules/KC0123456789ABCDEF\n            description: 'URI of created resource. TransactionId can be extracted from URI as it follows pattern /key-capsules/{transactionId}'\n        '400':\n        description: 'Bad request. Client error.'\n    requestBody:\n        content:\n        application/json:\n            schema:\n            $ref: '#/components/schemas/Capsule'\n    security: []\n    tags:\n        - cdoc2-key-capsules\ncomponents:\nschemas:\n    Capsule:\n    title: Capsule\n    type: object\n    properties:\n        recipient_id:\n        type: string\n        format: byte\n        minLength: 97 # EC public key\n        maxLength: 2100 # 16 K RSA public key = 2086 bytes\n        description: 'Binary format is defined by capsule_type'\n        ephemeral_key_material:\n        type: string\n        format: byte\n        maxLength: 2100\n        description: 'Binary format is defined by capsule_type'\n        capsule_type:\n        type: string\n        enum:\n            - ecc_secp384r1\n            - rsa\n        description: |\n            Depending on capsule type, Capsule fields have the following contents:\n            - ecc_secp384r1:\n                * recipient_id is EC pub key with secp384r1 curve in TLS format (0x04 + X coord 48 bytes + Y coord 48 bytes) (https://www.rfc-editor.org/rfc/rfc8446#section-4.2.8.2)\n                * ephemeral_key_material contains sender public EC key (generated) in TLS format.\n            - rsa:\n                * recipient_id is DER encoded RSA recipient public key - RsaPublicKey encoding [https://www.rfc-editor.org/rfc/rfc8017#page-54](RFC8017 RSA Public Key Syntax A.1.1)\n                * ephemeral_key_material contains KEK encrypted with recipient public RSA key\n    required:\n        - recipient_id\n        - ephemeral_key_material\n        - capsule_type\nsecuritySchemes:\n    mutualTLS:\n    # since mutualTLS is not supported by OAS 3.0.x, then define it as http basic auth. MutualTLS must be implemented\n    # manually anyway\n    #type: mutualTLS\n    type: http\n    scheme: basic\ntags:\n- name: cdoc2-key-capsules\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/appendix_d_keylabel/","title":"Appendix D: KeyLabel field specification","text":"<p><code>KeyLabel</code> field specification lists the following fields.</p> <p>Implementers may define their own vendor-specific field specification, but it's recommended to share it publicly.</p>"},{"location":"02_protocol_and_cryptography_spec/appendix_d_keylabel/#versioning","title":"Versioning","text":"<p>In current specification <code>type</code> and <code>v</code> fields are required, rest of fields are <code>type</code> specific.  <code>type</code> and <code>v</code> together define a KeyLabel type.</p> <p><code>v</code> describes type version. Version should only increase when there are breaking changes to type (basically define a new type). Adding/removing optional fields doesn't increase the version.</p> <p>Required fields are required only for UI. When <code>KeyLabel</code> parsing fails, then CDOC2 decryption should  still succeed as required fields for decryption are in <code>FlatBuffers</code> structure.</p> <p>Exception to this (decryption should succeed without <code>KeyLabel</code>) is symmetric key, when there is more  than 1 symmetric key recipient in CDOC2 header (key label needs to be unique to differentiate between  symmetric key recipients). </p>"},{"location":"02_protocol_and_cryptography_spec/appendix_d_keylabel/#eid-v1","title":"eID v1","text":"field description example required comments v Version 1 X type eID type: <code>ID-card</code> or <code>Digi-ID</code> or <code>Digi-ID E-RESIDENT</code> ID-card X cn Recipient common name as it is appears in certificate J\u00d5EORG,JAAK-KRISTJAN,38001085718 X serial_number SerialNumber as it appears in LDAP server PNOEE-38001085718 X last_name Recipient last name J\u00f5eorg first_name Recipient first name Jaak-Kristjan server_exp Set expiration date in capsule server as Unix timestamp (seconds) 1730992802 Added 18.11.24"},{"location":"02_protocol_and_cryptography_spec/appendix_d_keylabel/#certificate-from-file-v1-typecert","title":"Certificate from file v1 (type=cert)","text":"field description example required comments v Version 1 X type Certificate from file cert X file Recipient x509 certificate file 37101010021_cert.pem cn Common Name from certificate \u017dAIKOVSKI,IGOR,37101010021 cert_sha1 Certificate SHA1 Fingerprint 7F193CBFFA6A8D52C710FE961077817567449C59 server_exp Set expiration date in capsule server as Unix timestamp (seconds) 1730992802 Added 18.11.24"},{"location":"02_protocol_and_cryptography_spec/appendix_d_keylabel/#public-key-from-file-v1-typepub_key","title":"Public key from file v1 (type=pub_key)","text":"field description example required comments v Version 1 X type Public key from file pub_key X file Public key input file bob_pub.pem label label to identify public key from other keys, user-given or generated file:bob_pub.pem Addeded 18.11.24"},{"location":"02_protocol_and_cryptography_spec/appendix_d_keylabel/#symmetric-key-v1-typesecret","title":"Symmetric key v1 (type=secret)","text":"field description example required v Version 1 X type symmetric key secret X label label to identify symmetric key from other keys, user-given or generated yHqkRsP3kbQ X file"},{"location":"02_protocol_and_cryptography_spec/appendix_d_keylabel/#password-v1-typepw","title":"Password v1 (type=pw)","text":"field description example required v version 1 X type user-given password pw X label label to identify password from other passwords, user-given or generated Arno X"},{"location":"02_protocol_and_cryptography_spec/appendix_d_keylabel/#smart-idmobile-id-v1-typeauth","title":"Smart-ID/Mobile-ID v1 (type=auth)","text":"field description example required v Version 1 X type Smart-ID/Mobile-ID auth X pno (National) personal number ETSI:PNOEE-48010010101 X"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/","title":"CDOC2 encryption schemes","text":""},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#introduction","title":"Introduction","text":"<p>This section discusses encryption schemes, which are supported by CDOC2 system. The purpose of the section is to familiarize the reader with basic principles of encryption schemes and to specify, how the cryptographic primitives and other functions are used to compose CDOC2 encryption schemes. However, in this section, encryption schemes are presented in abstract form, and they are missing some details. For example, iteration count of PBKDF2 function is not defined here and additional arguments for the HKDF functions are not defined in this section. Such implementation details are specified in Cryptographic protocol details.</p> <p>Encryption schemes are presented in an abstract form, where Sender wants to send a message <code>M</code> (payload of the CDOC2 Container) to total of <code>l</code> Recipients (<code>Recipient_1</code>, <code>Recipient_2</code>, ... <code>Recipient_l</code>) and Recipients are all similar, in a sense that they all have similar RSA key pairs or that they all have established a password with Sender. In the actual CDOC2 system, Sender may mix different kind of Recipients and different encryption schemes may be concurrently used in the same CDOC2 Container. In that sense, encryption schemes defined in this section are not comparable to use-cases, which describe interaction details of user and CDOC2 system software components. Use-cases are discussed in section Client Application use cases.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#notation-and-functions","title":"Notation and functions","text":""},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#notation","title":"Notation","text":"<p>For convenience, we repeat here some of the acronyms and shorthand notation, which is used to define cryptographic schemes:</p> <ul> <li><code>M</code> - Message (payload of CDOC2 Container)</li> <li><code>C</code> - Ciphertext (encrypted message M)</li> <li><code>FMK</code> - File Master Key. Cryptographic key material for deriving other encryption and HMAC keys.</li> <li><code>CEK</code> - Content Encryption Key. Symmetric key used to encrypt the payload of CDOC2 Container.</li> <li><code>KEK</code> - Key Encryption Key. Symmetric key used to encrypt (wrap) the FMK, so that FMK could be transmitted inside CDOC2 Capsule (CKC).</li> <li>Index <code>i</code> is used to denote an instance of key or data structure, which is specific to certain Recipient, for example, <code>KEK_i</code>.</li> </ul>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#standard-cryptographic-functions","title":"Standard cryptographic functions","text":"<p>Schemes use following standard functions:</p> <ol> <li><code>Enc(CEK, M)</code> means encryption of message <code>M</code> with symmetric key <code>CEK</code>.</li> <li><code>HKDF()</code>, <code>HKDF-Extract()</code>, <code>HKDF-Expand()</code> are key derivation functions as defined in RFC5869 (https://datatracker.ietf.org/doc/html/rfc5869).</li> <li><code>ECSVDP-DH(SecretKey, PublicKey)</code> is Elliptic Curve Secret Value Derivation Primitive, Diffie-Hellman version, as defined in IEEE standard P1363 and in RFC5349 (https://datatracker.ietf.org/doc/html/rfc5349). Note that this is little-bit different from \"ECC Cofactor Diffie-Hellman (ECC CDH)\" as defined in NIST SP800-56A, section 5.7.1.2.</li> <li><code>RSAES-OAEP-ENCRYPT(PK, M)</code> means encryption of message <code>M</code> with RSA public key <code>PK</code> according to RFC8017, section 7.1.1 (https://datatracker.ietf.org/doc/html/rfc8017#section-7.1.1).</li> <li><code>RSAES-OAEP-DECRYPT(SK, C)</code> means decryption of ciphertext <code>C</code> with RSA private key <code>SK</code> according to RFC8017, section 7.1.2 (https://datatracker.ietf.org/doc/html/rfc8017#section-7.1.2)</li> <li><code>PBKDF2(Password, Salt)</code> is key material derivation function as defined in RFC2898 (https://www.ietf.org/rfc/rfc2898.txt).</li> <li><code>XOR(Key1, Key2)</code> is bitwise exclusive-or operation on symmetric keys.</li> </ol>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#generic-cdoc2-encryption-scheme","title":"Generic CDOC2 encryption scheme","text":"<p>In general, CDOC2 system implements encryption of payload of CDOC2 Container with the following generic steps:</p> <ol> <li>Sender generates a random FMK, which is used as a master key material for deriving other specific cryptographic keys.</li> <li>From FMK, Sender derives a CEK, which is used for encrypting the payload of CDOC2 Container, and additional HMAC keys, which are used to protect the integrity of CDOC2 Container.</li> <li>FMK is encrypted (wrapped) with a recipient-specific key encryption key (KEK) and added to the CDOC2 Container. It now depends on the capabilities of the Recipient, how this KEK is made available to Recipient, so that they could decrypt the encrypted FMK and in turn, the whole Container. For example, some Recipients may be able to use eID means, which are capable of Diffie-Hellman key exchange, some may be able to use authentication-only eID means and some may only be able to use pre-shared password.</li> <li>Suitable encryption scheme for each Recipient is used and required information to execute key-establishment protocol or key-derivation protocol is put into data structure called \"capsule\" (Capsule). In some cases, the Capsule is transmitted along the CDOC2 Container itself and in some cases, Capsule Server(s) could be used.</li> </ol> <p>An example activity diagram about creating CDOC2 Container with multiple recipients, is given below:</p> <p></p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-schemes-with-key-establishment-algorithms","title":"Encryption schemes with key-establishment algorithms","text":"<p>These schemes are usable in case Recipients have eID means with some type of asymmetric key pair (such as RSA or EC), and this key pair could be used do derive the FMK decryption key (KEK) between Sender and Recipient, with some kind of key-establishment protocol. CDOC2 Container will contain the encrypted payload and capsule, which contains necessary information to execute the key-establishment protocol. Container and capsule will be transmitted to Recipient in the same communication channel.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#sc01-encryption-scheme-for-recipients-with-ec-key-pair","title":"SC01: Encryption scheme for Recipients with EC key pair","text":"<p>This scheme can be used for transmitting encrypted messages to Recipients holding an EC key pair. Scheme uses Diffie-Hellman key exchange algorithm to generate same secret value for both Sender and Recipient, which is used to protect the FMK of CDOC2 Container.</p> <p>The key exchange algorithm is almost the same as NIST key-establishment scheme <code>C(1e, 1s, ECC CDH)</code> (SP 800-56A Rev3, Section 6.2.2.2 - \"(Cofactor) One-Pass Diffie-Hellman, C(1e, 1s, ECC CDH) Scheme\"), with the only difference that NIST describes a key-establishment scheme with cofactor ECC CDH primitive, but we are using ECC DH primitive without a cofactor.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-steps-by-sender","title":"Encryption steps by Sender","text":"<p>Sender knows the ECC public keys <code>PK_1</code>, <code>PK_2</code>, ..., <code>PK_l</code> of recipients <code>B_1</code>, <code>B_2</code>, ..., <code>B_l</code>. Recipients hold corresponding ECC secret keys <code>SK_1</code>, <code>SK_2</code>, ..., <code>SK_l</code>.</p> <pre><code>FMK = HKDF-Extract(StaticFMKSalt, CSRNG())\nCEK = HKDF-Expand(FMK)\nC = Enc(CEK, M)\n{EphemeralPK, EphemeralSK} = CSRNG()\nKEK_i = HKDF(StaticKEKSalt, ECSVDP-DH(EphemeralSK, PK_i))\nCapsule_i = {EllipticCurveInfo, EphemeralPK, PK_i}\nEncryptedFMK_i = XOR(FMK, KEK_i)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#decryption-steps-by-recipients","title":"Decryption steps by Recipients","text":"<p>Recipient <code>i</code> receives the CDOC2 <code>Container_i</code> with data <code>{C, EncryptedFMK_i, Capsule_i}</code> and has ECDSA public key <code>PK_i</code> and corresponding ECDSA secret key <code>SK_i</code>.</p> <pre><code>EncryptedFMK_i = Container_i.EncryptedFMK_i\nSenderEphemeralPK = Capsule_i.EphemeralPK\nKEK_i = HKDF(StaticKEKSalt, ECSVDP-DH(SK_i, EphemeralPK))\nFMK = XOR(KEK_i, EncryptedFMK_i)\nCEK = HKDF-Expand(FMK)\nM = Dec(CEK, C)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-schemes-with-asymmetric-public-key-encryption-system","title":"Encryption schemes with asymmetric public key encryption system","text":""},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#sc02-encryption-scheme-for-recipients-with-rsa-key-pair","title":"SC02: Encryption scheme for recipients with RSA key pair","text":"<p>This scheme can be used for transmitting encrypted messages to Recipients holding a RSA key pair. Scheme uses RSA-OAEP encryption scheme to protect the FMK decryption key (KEK). Wrapped KEK is included in the capsule, which is transmitted to the Recipient within the CDOC2 Container.</p> <p>Note that, while it is also possible to use Diffie-Hellman key exchange algorithm with RSA key pair, in order to derive the KEK between Sender and Recipient, a direct RSAES-PKCS1-v1_5 or RSA-OAEP encryption scheme has been traditionally used with CDOC1 applications and therefore, support for this scheme has been carried over to CDOC2 system as well.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-steps-by-sender_1","title":"Encryption steps by Sender","text":"<p>Sender knows the RSA public keys <code>PK_1</code>, <code>PK_2</code>, ..., <code>PK_l</code> of recipients <code>B_1</code>, <code>B_2</code>, ..., <code>B_l</code>. Recipients hold corresponding RSA secret keys <code>SK_1</code>, <code>SK_2</code>, ..., <code>SK_l</code>.</p> <pre><code>FMK = HKDF-Extract(StaticFMKSalt, CSRNG())\nCEK = HKDF-Expand(FMK)\nC = Enc(CEK, M)\nKEK_i = CSRNG()\nEncryptedKEK_i = RSAES-OAEP-ENCRYPT(PK_i, KEK_i)\nCapsule_i = {EncryptedKEK_i, PK_i}\nEncryptedFMK_i = XOR(FMK, KEK_i)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#decryption-steps-by-recipients_1","title":"Decryption steps by Recipients","text":"<p>Recipient <code>i</code> receives the CDOC2 <code>Container_i</code> with data <code>{C, EncryptedFMK_i, Capsule_i}</code> and has RSA public key <code>PK_i</code> and corresponding RSA secret key <code>SK_i</code>.</p> <pre><code>EncryptedFMK_i = Container_i.EncryptedFMK\nEncryptedKEK_i = Capsule_i.EncryptedKEK\nKEK_i = RSAES-OAEP-DECRYPT(SK_i, EncryptedKEK_i)\nFMK = XOR(KEK_i, EncryptedFMK_i)\nCEK = HKDF-Expand(FMK)\nM = Dec(CEK, C)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-schemes-using-capsule-servers","title":"Encryption schemes using Capsule Servers","text":"<p>These schemes are usable, in case the Sender wishes to use Capsule Server as a separate transmission channel for sending key capsules to Recipients. CDOC2 Container itself is still transmitted within the usual transmission channel.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#sc03-encryption-scheme-with-capsule-server-for-recipients-with-ec-key-pairs","title":"SC03: Encryption scheme with capsule server for recipients with EC key pairs","text":"<p>This scheme uses same kind of key-establishment algorithm, as scheme SC01, but Capsule is transmitted via the Capsule Servers.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-steps-by-sender_2","title":"Encryption steps by Sender","text":"<p>Sender knows the ECC public keys <code>PK_1</code>, <code>PK_2</code>, ..., <code>PK_l</code> of recipients <code>B_1</code>, <code>B_2</code>, ..., <code>B_l</code>. Recipients hold corresponding ECC secret keys <code>SK_1</code>, <code>SK_2</code>, ..., <code>SK_l</code>.</p> <pre><code>FMK = HKDF-Extract(StaticFMKSalt, CSRNG())\nCEK = HKDF-Expand(FMK)\nC = Enc(CEK, M)\n{EphemeralPK, EphemeralSK} = CSRNG()\nKEK_i = HKDF(StaticKEKSalt, ECSVDP-DH(EphemeralSK, PK_i))\nKeyServerCapsule_i = {EphemeralPK, PK_i}\nContainerCapsule_i = {KeyServerCapsuleID_i}\nEncryptedFMK_i = XOR(FMK, KEK_i)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#decryption-steps-by-recipients_2","title":"Decryption steps by Recipients","text":"<p>Recipient <code>i</code> receives the CDOC2 <code>Container_i</code> with data <code>{C, EncryptedFMK_i, ContainerCapsule_i}</code> and has ECDSA public key <code>PK_i</code> and corresponding ECDSA secret key <code>SK_i</code>. Recipient reads <code>KeyServerCapsuleID_i</code> from <code>ContainerCapsule_i</code> and downloads corresponding <code>KeyServerCapsule_i</code> from Capsule Server.</p> <p>Decryption steps are exactly the same:</p> <pre><code>EncryptedFMK_i = Container_i.EncryptedFMK_i\nSenderEphemeralPK = KeyServerCapsule_i.EphemeralPK\nKEK_i = HKDF(StaticKEKSalt, ECSVDP-DH(SK_i, EphemeralPK))\nFMK = XOR(KEK_i, EncryptedFMK_i)\nCEK = HKDF-Expand(FMK)\nM = Dec(CEK, C)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#sc04-encryption-scheme-with-capsule-server-for-recipients-with-rsa-key-pairs","title":"SC04: Encryption scheme with Capsule Server for recipients with RSA key pairs","text":"<p>This scheme uses same kind of RSA-OAEP encryption scheme, as scheme SC02, but Capsule is transmitted via Capsule Server.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-steps-by-sender_3","title":"Encryption steps by Sender","text":"<p>Sender knows the RSA public keys <code>PK_1</code>, <code>PK_2</code>, ..., <code>PK_l</code> of recipients <code>B_1</code>, <code>B_2</code>, ..., <code>B_l</code>. Recipients hold corresponding RSA secret keys <code>SK_1</code>, <code>SK_2</code>, ..., <code>SK_l</code>.</p> <pre><code>FMK = HKDF-Extract(StaticFMKSalt, CSRNG())\nCEK = HKDF-Expand(FMK)\nC = Enc(CEK, M)\nKEK_i = CSRNG()\nEncryptedKEK_i = RSAES-OAEP-ENCRYPT(PK_i, KEK_i)\nKeyServerCapsule_i = {{EncryptedKEK_i, PK_i}\nContainerCapsule_i = {KeyServerCapsuleID_i, PK_i}\nEncryptedFMK_i = XOR(FMK, KEK_i)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#decryption-steps-by-recipients_3","title":"Decryption steps by Recipients","text":"<p>Recipient <code>i</code> receives the CDOC2 <code>Container_i</code> with data <code>{C, EncryptedFMK_i, ContainerCapsule_i}</code> and has RSA public key <code>PK_i</code> and corresponding RSA secret key <code>SK_i</code>. Recipient reads <code>KeyServerCapsuleID_i</code> from <code>ContainerCapsule_i</code> and downloads corresponding <code>KeyServerCapsule_i</code> from Capsule server. Recipient authenticates to Capsule Server with RSA key pair <code>(SK_i, PK_i)</code>.</p> <p>Decryption steps are exactly the same:</p> <pre><code>EncryptedFMK_i = Container_i.EncryptedFMK\nEncryptedKEK_i = KeyServerCapsule_i.EncryptedKEK\nKEK_i = RSAES-OAEP-DECRYPT(SK_i, EncryptedKEK_i)\nFMK = XOR(KEK_i, EncryptedFMK_i)\nCEK = HKDF-Expand(FMK)\nM = Dec(CEK, C)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-schemes-with-pre-shared-secrets","title":"Encryption schemes with pre-shared secrets","text":"<p>Previous schemes SC01, SC02, SC03, and SC04 all use some form of pair-wise key-establishment protocols, and they are relying on the fact that recipients have access to RSA or EC key pairs, usually in the form of eID means. In addition to these schemes, CDOC2 system have to support situations, where Recipients don't have any such tokens, or when the storage requirements of CDOC2 Container exceed usable lifetime of such tokens. In these cases, it is possible to use pre-shared symmetric encryption key or pre-shared password.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#sc05-encryption-scheme-for-recipients-with-pre-shared-symmetric-secret","title":"SC05: Encryption scheme for recipients with pre-shared symmetric secret","text":"<p>This scheme is used, when Sender wishes to use an externally generated symmetric encryption key for:</p> <ul> <li>long-term storage of CDOC2 Container, so that decryption of it doesn't depend on availability of hardware tokens or validity of PKI certificates, and/or</li> <li>transmitting CDOC2 Container to such Receivers, who doesn't have any eID means, but who have previously received the symmetric encryption key.</li> </ul> <p>Encryption scheme can be used with multiple Recipients, who each may know different encryption key. This encryption scheme is very similar to scheme SC06, which uses pre-shared password or passphrase.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-steps-by-sender_4","title":"Encryption steps by Sender","text":"<p>Sender knows symmetric keys <code>S_1</code>, <code>S_2</code>, ..., <code>S_l</code> for each Recipient <code>B_1</code>, <code>B_2</code>, ..., <code>B_l</code>.</p> <pre><code>FMK = HKDF-Extract(StaticFMKSalt, CSRNG())\nCEK = HKDF-Expand(FMK)\nC = Enc(CEK, M)\nKeyMaterialSalt_i = CSRNG()\nKEK_i = HKDF(KeyMaterialSalt_i, S_i)\nEncryptedKEK_i = Enc(S_i, KEK_i)\nCapsule_i = {EncryptedKEK_i, KeyMaterialSalt_i}\nEncryptedFMK_i = XOR(FMK, KEK_i)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#decryption-steps-for-recipients-or-sender","title":"Decryption steps for Recipients or Sender","text":"<p>Recipient <code>i</code> receives the CDOC2 <code>Container_i</code> with data <code>{C, EncryptedFMK_i, Capsule_i}</code> and knows symmetric key <code>S_i</code>. Also, Sender may assume the role of any Recipient <code>i</code>.</p> <pre><code>EncryptedKEK_i = Capsule_i.EncryptedKEK\nKeyMaterialSalt_i = Capsule_i.KeyMaterialSalt\nEncryptedFMK_i = Container_i.EncryptedFMK\nKEK_i = HKDF(KeyMaterialSalt_i, S_i)\nFMK = XOR(KEK_i, EncryptedFMK_i)\nCEK = HKDF-Expand(FMK)\nM = Dec(CEK, C)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#sc06-direct-encryption-scheme-with-pre-shared-passwords","title":"SC06: Direct encryption scheme with pre-shared passwords","text":"<p>This scheme is used, when Sender wishes to use a password-based encryption for:</p> <ul> <li>long-term storage of CDOC2 Container, so that decryption of it doesn't depend on availability of hardware tokens or validity of PKI certificates, and/or</li> <li>transmitting CDOC2 Container to such Receivers, who doesn't have any eID means.</li> </ul> <p>Password-based encryption scheme can be used with multiple Recipients, who each may know a different password for decryption. This encryption scheme is very similar to scheme SC05, which uses pre-shared encryption key(s).</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-steps-by-sender_5","title":"Encryption steps by Sender","text":"<p>Sender knows passwords <code>Password_1</code>, <code>Password_2</code>, ..., <code>Password_l</code> for each Recipient <code>B_1</code>, <code>B_2</code>, ..., <code>B_l</code> and follows steps for encryption:</p> <pre><code>FMK = HKDF-Extract(StaticFMKSalt, CSRNG())\nCEK = HKDF-Expand(FMK)\nC = Enc(CEK, M)\nPasswordSalt_i = CSRNG()\nPasswordKeyMaterial_i = PBKDF2(Password_i, PasswordSalt_i)\nKeyMaterialSalt_i = CSRNG()\nKEK_i = HKDF(KeyMaterialSalt_i, PasswordKeyMaterial_i)\nCapsule_i = {KeyMaterialSalt_i, PasswordSalt_i}\nEncryptedFMK_i = XOR(FMK, KEK_i)\n</code></pre> <p>Sender creates a CDOC2 Container for each Recipient with <code>{C, EncryptedFMK_i, Capsule_i}</code>, including other technical details, and sends the Container to Recipient or places in long-term storage for themselves.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#decryption-steps-for-recipient-or-sender","title":"Decryption steps for Recipient or Sender","text":"<p>After some time, Sender may wish to decrypt the Container themselves (assuming the role of any Recipient <code>i</code>) or the Recipient <code>i</code> wishes to decrypt the Container.</p> <p>Recipient <code>i</code> receives CDOC2 <code>Container_i</code> with data <code>{C, EncryptedFMK, Capsule}</code> and has password <code>Password_i</code> and follows steps for decryption:</p> <pre><code>PasswordSalt_i = Capsule_i.PasswordSalt\nPasswordKeyMaterial_i = PBKDF2(Password_i, PasswordSalt_i)\nKeyMaterialSalt_i = Capsule_i.KeyMaterialSalt\nEncryptedFMK_i = Container_i.EncryptedFMK\nKEK_i = HKDF(KeyMaterialSalt_i, PasswordKeyMaterial_i)\nFMK = XOR(KEK_i, EncryptedFMK_i)\nCEK = HKDF-Expand(FMK)\nM = Dec(CEK, C)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-schemes-with-secret-sharing","title":"Encryption schemes with secret sharing","text":""},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#sc07-encryption-scheme-with-n-of-n-secret-shared-decryption-key","title":"SC07: Encryption scheme with (n-of-n) secret shared decryption key","text":"<p>This scheme is used, when Sender wishes to use multiple CDOC2 Shares Servers (CSS) do distribute the key material necessary to decrypt CDOC2 Container among the servers and this way to reduce the need to trust a single CSS server. Scheme uses simple n-of-n solution, where recipient needs to download all <code>n</code> shares in order to reconstruct the key material.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#encryption-steps-by-sender_6","title":"Encryption steps by Sender","text":"<p>Following steps outline how to create CDOC2 Container with a Recipient header structure and a Capsule for Recipient <code>i</code>. Index <code>i</code> is for enumerating over Recipients from <code>(1, 2, 3, ..., l)</code>. Index <code>j</code> is for enumerating over shares from <code>(1, 2, 3, ..., n)</code> of <code>KEK_i</code>.</p> <pre><code>FMK = HKDF_Extract(Static_FMK_Salt, CSRNG())\nCEK = HKDF_Expand(FMK)\nC = Enc(CEK, M)\n\nfor i in (1, 2, ... l): \n   KeyMaterialSalt_i = CSRNG()\n   KEK_i = HKDF_Expand(HKDF_Extract(KeyMaterialSalt_i, CSRNG()))\n   for j in (2, 3, ..., n):\n      KEK_i_share_j = CSRNG() \n   KEK_i_share_1 = XOR(KEK_i, KEK_i_share_2, KEK_i_share_3,..., KEK_i_share_n)\n   # Client uploads all shares of KEK_i to CSS servers and \n   # gets corresponding Capsule_i_Share_j_ID for each KEK_i_share_j\n   RecipientInfo_i = \"etsi/PNOEE-48010010101\"\n   DistributedKEKInfo_i = {CSS_ID, Capsule_i_Share_j_ID}\n   Capsule_i = {RecipientInfo_i, DistributedKEKInfo_i}\n   EncryptedFMK_i = XOR(FMK, KEK_i)\n\nContainer = {C, EncryptedFMK_i [1..l], Capsule_i [1..l]}\n</code></pre> <p>Sender has created a CDOC2 Container containing <code>{C, EncryptedFMK_i [1..l], Capsule_i [1..l]}</code> for transmitting to Recipients <code>(1..l)</code>.</p>"},{"location":"02_protocol_and_cryptography_spec/ch02_encryption_schemes/#decryption-steps-by-recipient","title":"Decryption steps by Recipient","text":"<p>Recipient <code>i</code> receives a CDOC2 Container containing <code>{C, EncryptedFMK_i [1..l], Capsule_i [1..l]}</code>, where <code>Capsule_i = {RecipientInfo_i, DistributedKEKInfo_i}</code> and <code>DistributedKEKInfo_i = {CSS_ID, Capsule_i_Share_j_ID} [1..n]</code>.</p> <p>Authentication signature data format and authentication token details are specified in section Capsule Server.</p> <pre><code># Recipient sends `Capsule_i_Share_j_ID` to corresponding CSS servers\n# and receives `nonce_i_j` from each server\nauth_data = {Capsule_i_Share_j_ID, SHA256(nonce_i_j)}\nauth_hash = SHA256(auth_data)\n# Recipient performs ID-card/Mobile-ID/Smart-ID authentication\n# and creates a signature `auth_signature` on `auth_hash` \n# with authentication key pair.\nauth_signature = sign(auth_hash) \nfor j in [1, 2, 3, ... n]: \n   auth_token_j = auth_data_for_server_j + auth_signature\nKEK_i = XOR(KEK_i_share_1, KEK_i_share_2, KEK_i_share_3,..., KEK_i_share_n)\nFMK = XOR(KEK_i, EncryptedFMK_i)\nCEK = HKDF_Expand(FMK)\nM = Dec(CEK, C)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/","title":"CDOC2 container format","text":""},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#abstracted-format","title":"Abstracted format","text":"<p>This section describes the CDOC2 format from an abstract point of view, presenting the data contents and data models used therein without referencing the specifics of the serialized format.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#basic-principles","title":"Basic principles","text":"<p>The basic principles outlined below will provide the user of this specification with points of reference for understanding the details of the specification.</p> <ul> <li>The abstracted format consists of a header and an encrypted payload.</li> <li>The abstracted format contains a single encrypted payload consisting of one or several encrypted files. File information, as well as the sizes and sequence of the files, in case there is more than one file, is also encrypted.</li> <li>The payload is encrypted using a single symmetric key (Content Encryption Key; CEK), using AEAD (Authenticated Encryption with Additional Data) encryption.</li> <li>The CEK is derived from the CDOC file master key (File Master Key; FMK). See section Key derivation.</li> <li>The FMK can be encrypted in parallel using one or several key encryption keys (KEK), one per recipient. On KEK generation see section Descriptions of header elements and KEK computation.</li> <li>The header describes the protection of the FMK (i.e. how the recipients can acquire the KEK required for decrypting the FMK).</li> <li>Header integrity is ensured using a message authentication code computed using the message authentication key derived from the FMK (Header HMAC Key; HHK). See section Header authentication code.</li> <li>To ensure format universality, no elements specific to the Estonian eID infrastructure have been used in the description. Thus, the recipient is described with reference to their public key rather than their certificate.</li> <li>Decryption always follows the same pattern: 1) the recipient acquires a KEK, 2) the recipient decrypts the FMK, 3) the recipient derives the HHK and validates the header, 4) the recipient derives the CEK, 5) the recipient decrypts the payload.</li> </ul>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#header-structure","title":"Header structure","text":"<p>Header structure is described with the help of pseudocode that is based on no specific programming or schema language but should be intuitively understood.</p> <p>The header consists of one or several structures describing a recipient. Each recipient structure contains complete information on how the specific recipient can access the FMK (for identification, access to personal encrypted materials, etc.).</p> <p>A message authentication code is computed for the header using a key derived from the FMK. This is necessary for preventing the manipulation of the header by the senders, e.g. for the purpose of concealing some recipient. The header authentication code is computed for a header serialized in a specific manner (see section Serialized format).</p> <pre><code>Header = {\n    Recipients              = :Recipient[](1..k)\n    PayloadEncryptionMethod = :enum(CHACHA20-POLY1305)\n}\n</code></pre> <p>A message authentication code is computed for the header (see section Header authentication code):</p> <pre><code>Checksum = {\n    value = HMAC(HHK, Serialize(Header))\n}\n</code></pre> <p></p> <p></p> <p></p> <p>The recipient is described using the structure <code>Recipient</code>. The format of the structure allows for quick and unambiguous decisions on whether the reader can decrypt the payload using the specific instance of <code>Recipient</code>.</p> <pre><code>Recipient = {\n    Capsule = Union(:ECCPublicKeyCapsule | :KeyServerCapsule | \n            :SymmetricKeyCapsule | :RSAPublicKeyCapsule )\n    KeyLabel = :string\n    EncryptedFMK = :byte[]\n    FMKEncryptionMethod = :enum(XOR)\n}\n</code></pre> <p>The <code>Recipient</code> structure consists of a capsule, a recipient key label, an encrypted FMK, and an FMK encryption method identifier.</p> <ul> <li><code>Capsule</code> \u2013 encryption method specific data that the recipient can use to decrypt the FMK.</li> <li><code>EncryptedFMK</code> \u2013 encrypted FMK.</li> <li><code>FMKEncryptionMethod</code> \u2013FMK encryption method type.</li> <li><code>KeyLabel</code> \u2013 human-readable label of the private or secret key required for decrypting the FMK. This label is necessary for building a sensible user interface. The sender fills this field based on the key or the related certificate. No concrete method for achieving this is indicated in the specification as this is not relevant to cryptographic processing. <code>KeyLabel</code> is a UTF-8 string.</li> </ul> <p>Successful processing of the Capsule structure returns a cryptographic key for decrypting the FMK using the method defined as <code>FMKEncryptionMethod</code>. See section 6.4 on the details of cryptographic operations. The following capsule types have been specified to ensure the support of a variety of encryption methods (CDOC2 encryption schemes).</p> <ul> <li><code>ECCPublicKeyCapsule</code> \u2013 the recipient is identified by ECC public key <code>RecipientPublicKey</code> (e.g. the public key of the first ID-card key pair). The KEK is derived using ECDH. Used in the SC.01 encryption method.</li> <li><code>RSAPublicKeyCapsule</code> \u2013 the recipient is identified by RSA public key <code>RecipientPublicKey</code>. The KEK is derived by decrypting the capsule using the RSA private key. Used in the SC.03 encryption method.</li> <li><code>KeyServerCapsule</code> \u2013 the recipient is identified by ECC or RSA public key <code>RecipientPublicKey</code>, used by the recipient for authentication on a Capsule Server. The Capsule Server returns an <code>ECCPublicKeyCapsule</code> or a <code>RSAPublicKeyCapsule</code> used as described above. Used in the  SC.02 and SC.04 encryption methods.</li> <li><code>SymmetricKeyCapsule</code> \u2013 the recipient is identified by key label <code>KeyLabel</code>. The KEK is derived using HKDF from a symmetric key provided by the user. Used in the SC.05 encryption method.</li> </ul> <p></p> <p></p> <p></p> <p>This list may be expanded in future versions of the specification.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#keylabel-recommendations","title":"KeyLabel recommendations","text":"<p>Although not required by the specification, <code>KeyLabel</code> should however follow consistent formating rules and be structured in a machine-readable format for Client Application to show the User what decryption method is allowed and, in case of password and symmetric key encryption, a reminder of what password or key to use.</p> <p>Dependent upon the encryption method the following formatting rules are used in the reference implementation:</p> <p>1. For machine parsable text data url format was chosen, that starts with <code>data:</code></p> <pre><code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;\n</code></pre> <p>The <code>mediatype</code> can be omitted and is application/x-www-form-urlencoded if not specified and fields are encoded as url parameters. Parameter names are case-insensitive. <code>;base64</code> encoding is optional and means then that Base64 encoded has been applied to the <code>&lt;data&gt;</code> part.</p> <p><code>type</code> and <code>v</code> fields are required, rest of fields are <code>type</code> specific.</p> <p>Examples:</p> <ul> <li>Smart-ID/Mobile-ID - PNO=ETSI:{ETSI indentifier} e.g. \"ETSI:PNOEE-48010010101\", where PNO means personal number issued by a national authority and {ETSI identifier} is replaced by the Recipient's identifier. Example: type=Smart-ID&amp;PNO=ETSI%3APNOEE-48010010101</li> <li>Password, with an integrated password manager - KM=bitwarden&amp;VAULT=CDOC2&amp;KEY_ID=HELLO.CDOC2&amp;USER_DESC=hello, where KM means key manager and VAULT refers to the name of a secure vault, keyring or wallet inside the password manager. KEY_ID is the name given to the key in the vault.</li> <li>Symmetric key - KM=bitwarden&amp;VAULT=CDOC2&amp;KEY_ID=HELLO.CDOC2&amp;FILE=~/folder/secret.pem&amp;USER_DESC=hello, where KM means key manager and VAULT refers to the name of a secure vault, keyring or wallet inside the password manager. KEY_ID is the name given to the key in the vault. FILE is the path to the symmetric key.</li> <li>Certificate - FILE=~/folder/filename&amp;CERT_HASH=XXYYXXYY, where FILE is the path to the certificate and CERT_HASH is a result of applying a digest algorithm.</li> <li>ID-card and Digi-ID and Digi-ID E-RESIDENT - TYPE=ID-card&amp;cn={cn}, TYPE means eID type. The current known values are: 'ID-CARD', 'Digi-ID E-RESIDENT', 'Digi-ID'. For these types the following fields and requirements are defined</li> </ul> <p>Known fields are defined in Appendix: KeyLabel field specification v1.</p> <p>Machine-readable <code>KeyLabel</code> examples:</p> <ul> <li><code>data:,v=1&amp;type=ID-card&amp;serial_number=PNOEE-38001085718&amp;cn=J%C3%95EORG%2CJAAK-KRISTJAN%2C38001085718</code></li> <li><code>data:application/x-www-form-urlencoded,v=1&amp;type=ID-card&amp;serial_number=PNOEE-38001085718&amp;cn=J%C3%95EORG%2CJAAK-KRISTJAN%2C38001085718</code></li> <li><code>data:application/x-www-form-urlencoded;base64,dj0xJnR5cGU9SUQtY2FyZCZzZXJpYWxfbnVtYmVyPVBOT0VFLTM4MDAxMDg1NzE4JmNuPUolQzMlOTVFT1JHJTJDSkFBSy1LUklTVEpBTiUyQzM4MDAxMDg1NzE4</code></li> <li><code>data:;base64,dj0xJnR5cGU9SUQtY2FyZCZzZXJpYWxfbnVtYmVyPVBOT0VFLTM4MDAxMDg1NzE4JmNuPUolQzMlOTVFT1JHJTJDSkFBSy1LUklTVEpBTiUyQzM4MDAxMDg1NzE4</code></li> </ul> <p>2. The second format for <code>KeyLabel</code> is free text format and it doesn't start with <code>data:</code></p> <p>This format is meant for password encryption and symmetric key encryption use cases when no integrated password manager is used.</p> <p>Free text <code>KeyLabel</code> examples:</p> <ul> <li>\"131:40:16\"</li> <li>\"kevade\"</li> <li>\"poem\"</li> <li>\"password manager, key: hello.cdoc2\"</li> </ul>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#capsule-types","title":"Capsule types","text":"<p>ECC public key capsule. The recipient is identified by ECC public key <code>RecipientPublicKey</code>.</p> <pre><code>ECCPublicKeyCapsule = {\n    Curve              = :enum(secp384r1)\n    RecipientPublicKey = :byte[]\n    SenderPublicKey    = :byte[]\n}\n</code></pre> <ul> <li><code>Curve</code> \u2013 identifier of the elliptic curve employed.</li> <li><code>RecipientPublicKey</code> \u2013 recipient\u2019s ECC public key, used by the recipient to establish the corresponding recipient record.</li> <li><code>SenderPublicKey</code> \u2013 sender\u2019s public key used by the recipient to derive the KEK using ECDH.</li> </ul> <p>RSA public key capsule. The recipient is identified by RSA public key <code>RecipientPublicKey</code>.</p> <pre><code>RSAPublicKeyCapsule = {\n    RecipientPublicKey = :byte[]\n    EncryptedKEK       = :byte[]\n}\n</code></pre> <ul> <li><code>RecipientPublicKey</code> - recipient\u2019s RSA public key, used by the recipient to establish the corresponding recipient record.</li> <li><code>EncryptedKEK</code> -  key encryption key encrypted with the receipient's public key.</li> </ul> <p>Server capsule. The receipient is identified by ECC or RSA public key <code>RecipientPublicKey</code>.</p> <pre><code>KeyServerCapsule = {\n    RecipientKey = Union(:EccKeyDetails | :RsaKeyDetails)\n    KeyServerID         = :string\n    TransactionID       = :string\n}\n\nRsaKeyDetails = {\n    RecipientPublicKey  = :byte[]\n}\n\nEccKeyDetails = {\n        Curve              = :enum(secp384r1)\n        RecipientPublicKey = :byte[]\n}\n</code></pre> <ul> <li><code>RecipientKey</code> \u2013 information on the recipient key, used by the recipient for authentication on the Capsule Server.</li> <li><code>KeyServerID</code> \u2013 Capsule Server identifier. The recipient must be able to use this to establish the Capsule Server\u2019s network address and connect to the server.</li> <li><code>TransactionID</code> \u2013 identifier of the capsule sent to the key exchange server by the sender for transmission to the recipient.</li> </ul> <p>Symmetric key capsule. The recipient is identified by the label of the symmetric key held by the user, <code>KeyLabel</code>.</p> <pre><code>SymmetricKeyCapsule = {\n    Salt   = :byte[]\n}\n</code></pre> <ul> <li><code>Salt</code> \u2013 random number generated by the sender, used by the sender as input for the HKDF-Extract function.</li> </ul>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#format-extension","title":"Format extension","text":"<p>To allow for format extension and ensure general forward compatibility, the union type field Capsule is included in the header structure Recipient. Each type of the union describes a specific type of recipient along with corresponding cryptographic primitives and key management tools. Types can be added to the format as necessary both in abstracted and concrete forms.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#serialized-format","title":"Serialized format","text":"<p>The specification describes the implementation of the abstracted format using the FlatBuffers format.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#general-description-of-the-format","title":"General description of the format","text":"<p>The format consists of an envelope, which is essentially made up of a serialized and concatenated header, a message authentication code, and a payload. The message authentication code and payload are serialized using simple serialization. For the sake of extensibility and the necessity of transmitting messages identical to the header from the point of view of processing logic via the capsule server, the header is described here with reference to the FlatBuffers format. Aside from the header extension mechanism, the envelope used in this format also defines another point of extension. This point of extension is provided by the version identifier, set as 2 (byte value) in the specification. The identifier must be changed in the descriptions of new versions.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#envelope","title":"Envelope","text":"<p>The envelope consists of the following data elements, presented sequentially as bytes. The designation of the start and end of the envelope is outside the scope of the specification, insofar as the main and natural use case of the format is one where a CDOC file contains a single envelope.</p> <ul> <li>4 bytes: the string \u201cCDOC\u201d \u2013 format designator (prelude), UTF-8 encoded.</li> <li>1 byte: version identifier, set as 2 in the specification.</li> <li>4 bytes: length of the following header, big-endian order. Header length is a 32-bit signed integer, i.e. the maximum header size is 2 GB. For the sake of the simplicity of implementation, header size is limited to 1 MB (2<sup>20</sup> bytes).</li> <li>x bytes, where x is as defined above: serialized FlatBuffers header.</li> <li>32 bytes: header message authentication code (see section 6.5).</li> <li>The rest of the bytes, until the end of the envelope: payload encrypted using the method and key specified in the header.</li> </ul> <p>Table 1 presents an overview of the envelope structure. Table 1. Envelope structure</p> Field \u201cCDOC\u201d Version Header length Header HMAC Payload Length 4 1 4 Header length 32 Until end of envelope Start 1 5 6 10 10 + header length 10 + header length + 32"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#header-and-hmac","title":"Header and HMAC","text":"<p>The technical description (schema) of the FlatBuffers format can be found in the reference implementation source code repository, under <code>cdoc2-schema/</code>. The schema is described in two files and reproduced as appendices to the specification.</p> <ul> <li> <p><code>src/main/fbs/header.fbs</code> Description of the FlatBuffers header.</p> </li> <li> <p><code>src/main/fbs/recipients.fbs</code> Descriptions of recipient types; can be shared with schemas presented in other files.</p> </li> </ul> <p>The header, serialized following the FlatBuffers rule set, is written to the envelope, preceded a 4-byte length field as per the envelope description. The Header Message Authentication Code (HMAC) is computed as described in section Header authentication code and written, bytewise, immediately after the header. The message authentication code algorithm and, consequently, HMAC length are defined in this specification.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#payload","title":"Payload","text":"<p>Lastly, the payload is written to a container composed following the CDOC format, immediately after the HMAC. The format presumes that the end-of-payload indicator is defined outside the format, e.g. as end-of-file.</p> <p>Note that the end-of-payload indicator is purely optional: the true integrity of the payload is determined by whether the payload can be completely decrypted.</p> <p>The composition of the payload plaintext is described in section Unencrypted payload.</p> <p>The encryption of the payload is described in section Payload assembly and encryption.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#format-composition-procedure","title":"Format composition procedure","text":"<p>This section makes reference to the reference implementation source code, using Java package names and identifiers. References to source code are styled as monotype. The following steps are needed to compose a CDOC2 container.</p> <ul> <li>Compile the list of all recipients.</li> <li>Generate FMK, HHK, and CEK.</li> <li>Compose the header along with all corresponding cryptographic operations.</li> <li>Compute the HMAC.</li> <li>Generate the payload plaintext.</li> <li>Encrypt the payload.</li> <li>Generate the serialized envelope.</li> <li>Securely delete the FMK, HHK, and CEK values used during the procedure.</li> </ul> <p>Generation of the payload plaintext is described in section Unencrypted payload, <code>container.Tar.archiveFiles()</code>.</p> <p>Next, the cryptographic material used for the protection of the header and payload must be prepared. Generation and derivation of the corresponding keys (FMK, HHK, CEK) is described in section Key derivation, <code>container.Envelope.prepare()</code> and <code>container.Envelope()</code>.</p> <p>The list of all desired recipients must then be compiled and serialized, as the cryptographic methods used for ensuring the integrity of the container operate with an integral serialized header.</p> <p>The requisite cryptographic procedures described in sections Descriptions of header elements and KEK computation and FMK encryption and decryption must be executed for each recipient.</p> <p>The HMAC is then computed as per section Header authentication code.</p> <p>Payload encryption is described in section Payload assembly and encryption, <code>crypto.ChaChaCipher.encryptPayload()</code> and <code>crypto.ChaChaCipher.initChaChaOutputStream()</code>.</p> <p>The detailed serialized envelope format is presented in section Envelope.</p> <p>At the end of the encryption process, the employed cryptographic materials (symmetric keys, ephemeral private keys) must be securely deleted. Secure deletion significantly depends on the operational environment; in some cases (e.g. in JVM) it might not be possible. The developer must evaluate what options for secure deletion are provided by the employed programming language and operational environment.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#format-parsing-procedure","title":"Format parsing procedure","text":"<p>This section makes reference to the reference implementation source code, using Java package names and identifiers. References to source code are styled as monotype.</p> <p>The container parsing reference implementation is found in the function <code>container.Envelope.decrypt()</code>. This functions serves as the primary entry point into the decryption logic and its main purpose is to take the encrypted container provided as input and write all the files contained therein to the selected folder.</p> <p>The function does the following and all its alternative implementations must do the same while employing all relevant security checks.</p> <ul> <li>Parsing the envelope and decoding the envelope header.</li> <li>Decrypting/deriving the KEK.</li> <li>Decrypting/deriving the container-specific keys, i.e. FMK, HHK, and CEK.</li> <li>Checking the HMAC.</li> <li>Decrypting the archive.</li> <li>Extracting files from the encrypted archive and writes the files to the selected folder. In stream processing mode, decryption and extraction form a single operation.</li> </ul> <p>The envelope parsing and header decryption reference implementation is found in the function <code>container.Envelope.readFBSHeader()</code>.</p> <p>The header must be parsed using the FlatBuffers library, utilizing the root type fbs.header.Header (in the reference implementation, this is implemented as the function <code>fbs.header.Header.getRootAsHeader()</code> generated from the FlatBuffers schema).</p> <p>Parsing of the complete header is implemented as the reference implementation function <code>container.Envelope.deserializeFBSHeader()</code>.</p> <p>A recipient (Recipient) corresponding to the party processing the container must be found in the header and the KEK, FMK, and HHK must be derived or decrypted.</p> <p>Recipient identification methods corresponding to each encryption method are described in section Descriptions of header elements and KEK computation. In case no recipient corresponding to the processing party is not found, the container cannot be decrypted. In this case, the algorithm must return a \u201ccontainer not meant for opening by the processor\u201d error and terminate.</p> <p>KEK computation is described in section Descriptions of header elements and KEK computation. Should an error occur during KEK computation (e.g. the point is not located on the ellipse curve), the algorithm must return an error and terminate. KEK computation functions are found in the class <code>crypto.KekTools</code>.</p> <p>FMK decryption is described in section FMK encryption and decryption,  <code>crypto.Crypto.xor()</code>.</p> <p>HHK derivation procedure is described in section Key derivation, <code>crypto.Crypto.deriveHeaderHmacKey()</code>.</p> <p>The HHK and the original serialized form of the header must be used to check the HMAC using <code>container.Envelope.checkHmac()</code>.</p> <p>After a successful message authentication code check, the payload may be decrypted. In case the HMAC check was unsuccessful, the algorithm must return an error and terminate.</p> <p>Decryption requires deriving the CEK. The corresponding procedure is described in section Key derivation, <code>Crypto.deriveContentEncryptionKey()</code>.</p> <p>Payload decryption is carried out in three stages: decryption, cryptogram authentication, and unpacking the decrypted archive.</p> <p>Decryption and cryptogram authentication are described in section Payload assembly and encryption.</p> <p>Archive unpacking is described in section Requirements for payload unpacking.</p>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#unencrypted-payload","title":"Unencrypted payload","text":"<p>This section provides a more detailed description of the format and processing of the unencrypted payload.</p> <p>Main features of the format:</p> <ul> <li>The transmitted files are archived using the POSIX tar format.</li> <li>The archived files are packed using ZLIB, standardized in IETF RFC 1950.</li> </ul> <p>The container payload plaintext is formed as follows: the transmitted files (or file) are added to a POSIX tar archive which is then packed into the ZLIB format as a single bloc.</p> <pre><code>Implementation note: the DD4 client uses the relevant Qt wrapper functions to call the zlib library. Since these functions cannot be used in streaming mode, the specification recommends replacing the use of Qt wrappers with streaming mode zlib calls. This becomes especially crucial in storage cryptography where data volumes may be very high and encryption of the data in memory buffers in one piece may be unfeasible.\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#requirements-for-posix-tar-archive-assembly","title":"Requirements for POSIX tar archive assembly","text":"<p>Given the long history and large number of variations of the tar format, this subsection presents an overview of the requirements for archives created for CDOC2. The purpose of these requirements is to reduce compatibility issues between different client applications and/or operating systems and facilitate the save extraction of the files from the archive to the file system.</p> <ul> <li>Standardized POSIX tar dialect is used. This format is also known as \u2018POSIX 1003.1-2001\u2019 or \u2018PAX\u2019.</li> <li>All file names are UTF-8 encoded.</li> <li> <p>100B filenames supported by PAX extended header.</p> </li> <li> <p>8 GiB files supported by PAX extended header.</p> </li> <li>Filenames are added to the archive without basenames.</li> <li>Permission bits and other security attributes added to the archive are ignored (can be written but not read).</li> <li>Only normal files (type 0) are added to the archive.</li> <li>Files are processed as binary files.</li> </ul>"},{"location":"02_protocol_and_cryptography_spec/ch03_container_format/#requirements-for-payload-unpacking","title":"Requirements for payload unpacking","text":"<p>The payload format is chosen to enable unpacking in streaming mode. This means the encrypted payload does not have to be loaded to memory in one piece. The payload can be decrypted, unpacked, and files written to the disk in plaintext sequentially.</p> <p>When data is processed in streaming mode, the decrypted data will be used before encryption checksum verification. Unpacking must be done with account of the possibility that the payload could be faulty and not meet the rules set out in the specification or might have even been maliciously assembled by an attacker. As the sender of a CDOC2 container is unauthenticated, the possibility of the payload having been assembled by an attacker must always be accounted for, even if the encryption checksums match.</p> <p>When processing data in streaming mode, errors encountered in processing the plaintext (packing or archival errors) cannot be handled before the entire payload has been processed and the cryptogram authenticated. If cryptogram authentication fails, this must be reported as an error. Errors encountered in plaintext processing can only be reported if cryptogram authentication was successful. In case of an error, all created files must be deleted.</p> <pre><code>Below, we have described two types of attacks that software based on this specification must be able to deploy countermeasures against.\nThe list of potential attacks is inconclusive. Thus, any file might contain a virus or malware and needs to be checked by antivirus software before use, but this type of attack is not specific to CDOC2 but is equally valid for the use of files received from any untrusted source and is hence not covered here in more detail.\n</code></pre> <p>Attack 1: The attacker may create a compressed payload that will unpack into a massive file. This may cause the application to crash when the recipient processes this payload in memory. It can cause disk space to run out when written to disk. The pragmatic solution is to set a maximum size limit for unpacked files and continuously monitor free memory or free disk space during unpacking. If the files being unpacked are larger than permitted or free memory or free disk space has decreased below the permitted limit, unpacking must be aborted, files written to the disk in the process deleted, and the error reported.</p> <p>Attack 2: The attacker may manipulate the attributes of the files in the tar archive \u2013 file names, permission bits, security attributes and types. In case such a tar file is unpacked without additional checks, the attacker may be able to overwrite existing system files, add new files, create files invisible to normal users but necessary for certain attacks, etc.</p> <p>Since the CDOC2 container is not meant to serve as a universal archive format but simply provide a means for the simultaneous encryption of multiple files while retaining original file names for the user\u2019s convenience, a number of rules have been set out for the unpacking of tar files which will ensure protection from the forms of manipulation described above if enforced:</p> <ul> <li>File creation must ignore permission bits, file owner and group identifiers and other security attributes found in the archive \u2013 all files must be created non-executable, owned by the user running the application, and readable and writable by this    user.</li> <li>Only normal files (type 0) must be created. If the archive contains a file of some other type, abort unpacking, delete files written to the disk before this point, and return an error message. A correctly implemented CDOC2 client application should not create files containing files of other types.</li> <li>Validate file name safety before writing a file to the disk. If a file name containing unpermitted symbols is found, abort unpacking, delete files written to the disk before this point, and return an error message.</li> </ul> <p>File name safety verification serves the following purposes:</p> <ul> <li>Prevention of path traversal attacks and creation of files outside the folder selected by the user.</li> <li>Prevention of the creation of files with names containing special symbols, inaccessible or difficult to access for the user.</li> </ul> <p>Different operating systems have different requirements for file names. The pragmatic solution is to use a tried and tested method for validating file names received from untrusted sources. Using multiple validation mechanisms is advantageous.</p> <p>Pathvalidate is a comprehensive Python library for file name validation \u2013 similar checks must also be used in other programming languages.</p> <p>The SEI CERT coding standard describes an additional method for preventing path traversal.</p> <p>List of requirements for file names used in the reference implementation container.FileNameValidator:</p> <ul> <li>Cannot begin with a space or hyphen.</li> <li>Cannot end with a space or period.</li> <li>Cannot be any of the following: CON, PRN, AUX, NUL, COM[1-9], LPT[1-9].</li> <li>Cannot contain any of the following symbols: &lt;, &gt;, :, \\, /, |, ?, *.</li> <li>Cannot contain control characters.</li> <li>Cannot contain the Unicode character Right-To-Left Override (U+202E).</li> </ul>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/","title":"Cryptographic details","text":"<p>This section provides a detailed description of the cryptographic computations used with the CDOC2 format. Most of these computations are broader technological infrastructure-neutral, but some are specifically related to means of eID used in Estonia (above all, the ID-card). All such situations will be highlighted.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#security-level-and-used-cryptographic-algorithms","title":"Security level and used cryptographic algorithms","text":"<p>Recent studies (1), (2) give cause to assume that 128-bit security should be sufficiently secure even after 2031. This claim is also supported by a new study published in 2022 (3). Based on these results, we use the following algorithms:</p> <ul> <li>HKDF-SHA-256</li> <li>HMAC-SHA-256</li> <li>ChaCha20-Poly1305</li> </ul> <p>The SHA2 hash function family is a long-standing standard. Recent studies show that the SHA2 hash functions are still secure and SHA-256 provides 128-bit security.</p> <p>The HKDF key derivation function used here (see section Key derivation for more details) has been subject to an in-depth security analysis. The use of HKDF with a secure hash function is also recommended in the aforementioned study.</p> <p>A 128-bit key is sufficient for HMAC security.</p> <p>ChaCha20-Poly1305 is a secure (IND-CPA and INT-CTXT) authenticating encryption algorithm (see e.g.). As a stream cipher, ChaCha20 also provides 256-bit security by itself.</p> <p>XOR encryption (one-time pad) providing 256-bit security is used for FMK encryption.</p> <p>Key lengths used for symmetric keys:</p> <ul> <li>FMK \u2013 256 bits.</li> <li>HHK \u2013 256 bits.</li> <li>CEK \u2013 depends on the payload encryption algorithm used, 256 bits for ChaCha20-Poly1305.</li> <li>KEK \u2013 depends on the FMK encryption algorithm used, 256 bits for XOR.</li> </ul>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#key-derivation","title":"Key derivation","text":"<p>For key derivation, the CDOC2 format utilizes the HKDF key derivation function, codified as IETF RFC 5869.</p> <p>RFC 5869 defines two key derivation functions: <code>HKDF-Extrac</code>t and <code>HKDF-Expand</code>, the use of which will be discussed below. Hereafter, these functions will be referenced using the shorthands <code>Extract</code> and <code>Expand</code>.</p> <p>In all cases, key derivation is carried out using the SHA-256 hash function, meaning that the functions return a 256-bit value. To be used as input in functions, all textual constants must be UTF-8 encoded (in the present case, cryptographic functions take byte arrays and integers as input), quotation marks used in the specification are not part of the strings.</p> <p>Public symmetric keys are derived as follows.</p> <p>File Master Key, FMK</p> <p>FMK \u2190 Extract(\u201dCDOC20salt\u201d, random)</p> <p>Where CDOC20salt is a constant string and random is an at least 256-bit value generated using a cryptographically secure random number generator (CSPRNG).</p> <p>Content Encryption Key, CEK</p> <p>CEK \u2190 Expand(FMK, \u201dCDOC20cek\u201d, L<sub><sub>octets</sub></sub>)</p> <p>L<sub>octets</sub> defines the output length of the Expand function in bytes and must be equal to the key length of the used symmetric encryption algorithm (see section Payload assembly and encryption).</p> <p>Header HMAC Key, HHK</p> <p>HHK \u2190 Expand(FMK, \u201dCDOC20hmac\u201d, 32<sub><sub>octets</sub></sub>)</p> <p>Note that the length of the HHK derived in this manner is 256 bits, i.e. equal to the output length of the used SHA-256 hash algorithm. This is based on the recommendations presented in the HMAC standard.</p> <p>Key Encryption Key, KEK</p> <p>KEK derivation is immediately tied to the used recipient type, and is described in connection with the relevant format elements:</p> <ul> <li>ECCPublicKeyCapsule \u2013 section ECCPublicKeyCapsule.</li> <li>RSAPublicKeyCapsule \u2013 section RSAPublicKeyCapsule.</li> <li>KeyServerCapsule \u2013 section KeyServerCapsule.</li> <li>SymmetricKeyCapsule \u2013 section SymmetricKeyCapsule.</li> <li>KeySharesCapsule - section KeySharesCapsule.</li> </ul>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#descriptions-of-header-elements-and-kek-computation","title":"Descriptions of header elements and KEK computation","text":"<p>The abstracted structure of the header is described in section CDOC2 container format. Fields are described in the abstracted structure using primitive data types. The following section describes how to compute the fields and translate values to the primitive data type form.</p> <p>Key Encryption Key (KEK) computation depends on recipient type. Below, KEK computation is described with reference to each specific recipient type.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#eccpublickeycapsule","title":"ECCPublicKeyCapsule","text":"<p><code>ECCPublicKeyCapsule</code> (see table 2) refers to a recipient identified by their ECC public key. The CDOC2 format supports the use of any public key generated on a secp384r1 elliptic curve as the recipient. For example, the key can be the public key of the Estonian ID-card authentication key pair. For the secp384r1 curve, the TLS 1.3 encoding used for elliptic curve points is identical to the encoding used in CDOC 1.0. The <code>ECCPublicKeyCapsule</code> structure corresponds to the capsule capsi in the sense of the protocols presented in sections Direct key agreement-based ECDH and Capsule server-based ECDH.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#table-2-eccpublickeycapsule-elements","title":"Table 2. ECCPublicKeyCapsule elements","text":"Field Contents Encoding Curve Elliptic curve used; currently only secp384r1. Based on the format used; see scheme description. RecipientPublicKey Recipient\u2019s public key, e.g. ID-card key pair 1 public key. Public key is encoded following TLS 1.3 rules, section 4.2.8.2. SenderPublicKey Sender ephemeral (short-lived or even one-time) key pair public key Public key is encoded following TLS 1.3 rules, section 4.2.8.2. <p>The sender computes the KEK using the secret key of the ephemeral key pair they have generated, and the recipient\u2019s public key, using the elliptic-curve Diffie-Hellman key agreement protocol (ECDH), and passes the result to the specified key derivation function. The recipient performs a similar computation using the sender\u2019s ephemeral public key and the ID-card authentication key pair. Details of the computations are provided below.</p> <p>The sender\u2019s ephemeral key pair is anonymous, i.e. not tied to the sender\u2019s public identity in any way.</p> <p>In case there are multiple recipients, the sender can use the same ephemeral key pair over a single CDOC container.</p> <p>The sender\u2019s ephemeral key pair consists of a public and a secret key:</p> \\[(pk_{eph}, sk_{eph})\\] <p>The recipient holds their ID-card authentication key pair public key pkrec (assuming here that the recipient\u2019s private key is not immediately accessible).</p> <p>This key is also accessible to the sender. Mechanisms for the dissemination of the recipient's public key are outside the scope of this specification.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#kek-computation-during-encryption-eccpublickeycapsule","title":"KEK computation during encryption (ECCPublicKeyCapsule)","text":"<p>The shared ECDH secret is computed by the sender as follows:</p> \\[ S_{ecdh} \u2190 (s_{keph} \u00b7 pk_{rec})_x \\] <p>i.e. the shared secret is the elliptic curve x-coordinate computed in this manner. The shared secret is encoded as a big-endian byte array, the length of which in full bytes corresponds to the modulus length of the used elliptic curve in full bytes. For example, the modulus length of secp384r1 is 48 bytes.</p> <p>KEK is computed from the shared secret as follows:</p> \\[ KEK_{pm} \u2190 Extract(\u201dCDOC20kekpremaster\u201d, S_{ecdh}) \\] \\[ KEK \u2190 Expand(KEK_{pm}, \u201dCDOC20kek\u201d \u2225 algId \u2225 pk_{rec} \u2225 pk_{eph}, L_{&lt;sub&gt;octets&lt;/sub&gt;}) \\] <p>algId is the identifier of the cryptographic algorithm used for the encryption of the FMK defined as a string corresponding to the field Recipient.FMKEncryptionMethod (section FMK encryption and decryption).</p> <p>L<sub><sub>octets</sub></sub> defines the output length of the <code>Expand</code> function in bytes and is defined by the symmetric encryption algorithm used for FMK encryption.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#kek-computation-during-decryption-eccpublickeycapsule","title":"KEK computation during decryption (ECCPublicKeyCapsule)","text":"<p>The Estonian ID-card supports the use of an authentication key pair as one of the ECDH parties. This functionality can advantageously be used through the PKCS#11 <code>C_DERIVEKEY</code> function, employing the <code>CKM_ECDH1_DERIVE</code> mechanism. Key derivation can also be performed using the Windows <code>NCryptSecretAgreement</code> and <code>NCryptDeriveKey</code> encryption functions. <code>NCryptSecretAgreement</code> computes the Secdh and <code>NCryptDeriveKey</code> computes the KEKpm. <code>NCryptDeriveKey</code> parameters must be set as follows:</p> <ul> <li><code>hSharedSecret</code> \u2013 handle returned by <code>NCryptSecretAgreement</code>.</li> <li><code>pwszKDF</code> \u2013 the constant BCRYPT_KDF_HMAC.</li> <li><code>pParameterList</code> \u2013 algorithm parameters:</li> <li><code>KDF_HASH_ALGORITHM</code> \u2013 the constant <code>BCRYPT_SHA256_ALGORITHM</code>.</li> <li><code>KDF_HMAC_KEY</code> \u2013 the constant <code>CDOC20kekpremaster</code>.</li> <li><code>KDF_SECRET_PREPEND</code> \u2013 parameter omitted.</li> <li><code>KDF_SECRET_APPEND</code> \u2013 parameter omitted.</li> </ul> <p>All ID-cards used today should be able to validate elliptic curve points used as input in ECDH key derivation, but additional validation may be implemented in software supporting the CDOC format to provide more user-friendly error management.</p> <p>In order to validate whether the point Q = (x, y) is located on the curve, it must be verified whether x and y fall in the interval [0\u2026p \u2013 1], whether they satisfy the curve equation, and whether the point falls in the correct subgroup. For example, the formula for the curve P-384 can be presented as</p> \\[ y^2 \u2261 x^3 - 3x+b\\bmod p\\; \\] <p>It must also be verified that nQ = 0 and Q != 0. The constants b, p, and n are described in the Digital Signature Standard. The <code>C_DERIVEKEY</code> function takes the sender\u2019s ephemeral public key pkeph and a reference to the corresponding ID-card key pair (pkrec, skrec) as inputs. The recipient computes</p> \\[S_{ecdh}' \\leftarrow (sk_{rec}\\cdot pk_{eph})_{x}\\;\\] <p>Thanks to the algebraic properties of the elliptic curve, \\(S_{ecdh}=S_{ecdh}'\\).</p> <p>This shared secret must be used to compute KEK as described above with reference to encryption.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#rsapublickeycapsule","title":"RSAPublicKeyCapsule","text":"<p>RSAPublicKeyCapsule (see table 3) refers to a recipient identified by their RSA public key. The structure RSAPublicKeyCapsule corresponds to the capsule capsi in the sense of the protocols presented in sections Direct key agreement-based ECDH and Capsule server-based ECDH.</p> <p>The sender generates a random KEK and encrypts it using the recipient\u2019s RSA public key with OAEP padding. The recipient decrypts the encrypted KEK using their RSA private key. Details of the computations are provided below.</p> <p>The recipient\u2019s public key is also accessible to the sender. Mechanisms for the dissemination of the recipient's public key are outside the scope of this specification.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#table-3-rsapublickeycapsule-elements","title":"Table 3. RSAPublicKeyCapsule elements","text":"Field Contents Encoding RecipientPublicKey RSA public key Value: DER encoding of the ASN.1 structure RSAPublicKey (see section A.1.1) EncryptedKEK KEK encrypted using recipient\u2019s public key XXX"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#kek-computation-during-encryption-rsapublickeycapsule","title":"KEK computation during encryption (RSAPublicKeyCapsule)","text":"<p>The symmetric encryption algorithm used for the encryption of the FKM defines the KEK length L<sub>octets</sub>. The sender generates a random number KEK with a length of L<sub>octets</sub>.</p> <p>For the encryption of the KEK, the sender uses the RSA-OAEP (see section 7.1) encryption function. RSA-OAEP has three input parameters (see section A.2.1):     \u2022 <code>hashAlgorithm</code> \u2013 hash function used by the algorithm. We use the SHA-256 hash function (<code>id-sha256</code>).     \u2022 <code>maskGenAlgorithm</code> \u2013 mask generation function used by the algorithm. We use the MGF1 function (<code>id-mgf1</code>), parametrized by the SHA-256 hash function.     \u2022 <code>pSourceAlgorithm</code> \u2013 label source function. We use an empty label (<code>pSpecified Empty</code>).</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#kek-computation-during-decryption-rsapublickeycapsule","title":"KEK computation during decryption (RSAPublicKeyCapsule)","text":"<p>The recipient decrypts the encrypted KEK using their private key and the same parameters as were used for encryption.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#keyservercapsule","title":"KeyServerCapsule","text":"<p>The Capsule Server described by the <code>KeyServerCapsule</code> structure (see table 4) returns the following structures which are handled as described in the referenced sections:</p> <ul> <li>ECCPublicKeyCapsule: section ECCPublicKeyCapsule.</li> <li>RSAPublicKeyCapsule: section RSAPublicKeyCapsule.</li> </ul> <p>The details of using KeyServerCapsule are described in section Capsule server.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#table-4-keyservercapsule-elements","title":"Table 4. KeyServerCapsule elements","text":"Field Contents Encoding RecipientKey Information on recipient key used by the recipient for authentication with the capsule server. - KeyServerID Capsule server identifier. UTF-8 string assigned by the software trust anchor configuration, see section Server identification and trust. TransactionID Transaction identifier UTF-8 string assigned by the capsule server"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#symmetrickeycapsule","title":"SymmetricKeyCapsule","text":"<p>SymmetricKeyCapsule (see table 5) refers to a recipient identified by a key label. In this scheme, the sender and recipient are either the same person (use case: storage cryptography) or have previously exchanged a symmetric secret key outside the system (use case: transport cryptography). In both cases, both the sender and the recipient holds the same secret key, identified by a key label. The specification does not limit the selection of the label in any way.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#table-5-symmetrickeycapsule-elements","title":"Table 5. SymmetricKeyCapsule elements","text":"Field Contents Encoding Salt Random number generated by the sender, used as input for the HKDF-Extract function in KEK derivation Byte array"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#kek-computation-during-encryption-symmetrickeycapsule","title":"KEK computation during encryption (SymmetricKeyCapsule)","text":"<p>The sender holds the symmetric key sym labelled label. The sender generates the random number salt. The purpose of this number is to ensure the generation of a new KEK even when reusing the key sym. Since no practical upper limit can be set for the reuse of the key, the length of salt is chosen with a significant margin, i.e. 256 bits. KEK is computed from the symmetric key and the generated random number as follows:</p> \\[ KEK_{pm} \\leftarrow Extract(salt, sym) \\] \\[ KEK     \\leftarrow Expand(KEK_{pm}, \"CDOC20kek\" \\parallel algId \\parallel label, L_{octets}) \\] <p>Where algId is the identifier of the encryption algorithm used for the encryption of the FMK as a string, set as <code>Recipient.FMKEncryptionMethod</code> (section FMK encryption and decryption).</p> <p>L<sub>octets</sub> defines the output length of the <code>Expand</code> function in bytes, determined by the symmetric encryption algorithm used for the encryption of the FMK.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#kek-computation-during-decryption-symmetrickeycapsule","title":"KEK computation during decryption (SymmetricKeyCapsule)","text":"<p>The recipient holds the symmetric key sym labelled label. The Salt field of the SymmetricKeyCapsule structure provides the random number salt generated by the sender.</p> <p>This information is used for computing the KEK just as described above with reference to encryption.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#keysharescapsule","title":"KeySharesCapsule","text":"<p>Capsule type <code>KeySharesCapsule</code> refers to a situation, when the encryption/decryption key material is split between multiple CCS servers. The corresponding encryption/decryption scheme is SC07. In such cases, the KEK is not derived using any of the key establishment algorithms, but generated from CSRNG.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#kek-computation-during-encryption-keysharescapsule","title":"KEK computation during encryption (KeySharesCapsule)","text":"<pre><code># Constants: \n\n#identifier of the method, which is used to encrypt the plaintext FMK value:\nFMKEncryptionMethod = \"XOR\" \n\n# length of KEK_i in octets, so that it matches the length of FMK for the XOR() algorithm\nL = 32 \n\n# Recipient identifier: \nRecipientInfo_i = \"etsi/PNOEE-48010010101\"\n\n# KEK_i computation: \nKeyMaterialSalt_i = CSRNG(256)\nKeyMaterial_i = CSRNG(256)\nKEK_i_pm = HKDF_Extract(KeyMaterialSalt_i, KeyMaterial_i)\nKEK_i = HKDF_Expand(KEK_i_pm, \"CDOC2kek\" + FMKEncryptionMethod + RecipientInfo_i, L)\n# Splitting KEK_i into shares\nfor j in (2, 3, ..., n):\n   KEK_i_share_j = CSRNG(256) \nKEK_i_share_1 = XOR(KEK_i, KEK_i_share_2, KEK_i_share_3,..., KEK_i_share_n)\n</code></pre> <p>The reason for including <code>FMKEncryptionMethod</code> and <code>RecipientInfo_i</code> under the <code>HKDF_Expand()</code> function is that this ensures further differences of KEKs between multiple encryption sessions and may prevent some sort of replay attack, when the key is taken out of one context and submitted to another context.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#kek-computation-during-decryption-keysharescapsule","title":"KEK computation during decryption (KeySharesCapsule)","text":"<pre><code># KEK_i computation: \nKEK_i = XOR(KEK_i_share_1, KEK_i_share_2, KEK_i_share_3,..., KEK_i_share_n)\n</code></pre>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#fmk-encryption-and-decryption","title":"FMK encryption and decryption","text":"<p>The FMK is encrypted using the XOR operation.</p> <p>The FMK assumes that the KEK and FMK are of equal length, which can be ensured by using the HKDF key derivation method.</p> <p>For FMK encryption, the XOR operation is applied bitwise to the corresponding bits in the FMK and the KEK.</p> <p>For decryption, the XOR operation is applied bitwise to the corresponding bits in the cryptogram and the KEK.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#header-authentication-code","title":"Header authentication code","text":"<p>The header authentication code is computed with the HMAC algorithm, using the SHA-256 hash function.</p> <p>The HHK (see section Key derivation) is used as the key.</p> <p>HHK length must be at least equal to the output length of the used hash function, i.e. 256 bits.</p> \\[ HMACValue_{header} \\leftarrow HMAC_{SHA-256}(HHK, header) , \\] <p>where header is the serialized header in the form it is added to the envelope.</p> <p>Validation of the message authentication code requires computing the HHK from the parsed header, then computing a message authentication code for the serialized header read from the container and comparing the computed code with the message authentication code read from the container \u2013 the two values must be identical.</p>"},{"location":"02_protocol_and_cryptography_spec/ch05_cryptographic_details/#payload-assembly-and-encryption","title":"Payload assembly and encryption","text":"<p>NOTE: The section below describes the encryption of the payload as a byte array. The assembly of encrypted files into a single byte array is described in section Unencrypted payload.</p> <p>For payload encryption, ChaCha20-Poly1305 AEAD encryption is used with the following parameters:</p> <ul> <li>Key length: 256 bits</li> <li>Nonce length: 96 bits</li> <li>Authentication label length: 128 bits</li> </ul> <p>CEK is used as the key.</p> <p>The nonce (nonce) is always generated afresh, using a cryptographically secure random number generator (CSPRNG).</p> <p>Additional data (additionalData) comprises a predetermined UTF-8 encoded string, the serialized header, and the header message authentication code.</p> \\[  additionalData \\leftarrow \"CDOC20payload\" \\parallel header \\parallel headerHMAC \\] <p>Payload (payLoad) encryption is performed using the encryption function below, with an output length of plaintext payload length plus authentication label length.</p> \\[ encryptedPayload \\leftarrow encrypt_{cc20p1305}(CEK, nonce, payLoad, additionalData) \\] <p>Decryption of the encrypted payload is performed using the decryption function below.</p> \\[ payload \\leftarrow decrypt_{cc20p1305}(CEK, nonce, encryptedPayLoad, additionalData) \\] <p>When processing the payload in streaming mode, the plaintext will be handled before the decryption function has validated the authentication label. Requirements for plaintext processing and error handling are detailed in section Requirements for payload unpacking. It is critical to delete all files if authentication label validation fails.</p> <p>The encrypted payload is serialized along with the nonce, as the nonce has to be transmitted to the recipient.</p> \\[ serializedPayload \\leftarrow nonce \\parallel encryptedPayLoad \\] <p>In the case of the format envelope, payload means an encrypted and serialized payload (serializedPayload). Nonce and other details have not been explicated in the description of the envelope as they depend on the encryption method employed.</p>"},{"location":"03_system_architecture/ch01_system_context/","title":"System Context","text":""},{"location":"03_system_architecture/ch01_system_context/#overview","title":"Overview","text":"<p>\"CDOC2 system\" - IT system, which contains following primary components:</p> <ol> <li>CDOC2 Capsule Server (CCS) to be used by CDOC2 clients, such as reference CLI client and DigiDoc4 client application. Every CDOC2 Capsule Server uses local database component as well.</li> <li>CDOC2 reference library, to be used by CDOC2 servers, CLI client ~~and DigiDoc4 client application~~</li> <li>CDOC2 CLI client, which is a command-line Java application and which implements all CDOC2 end-user usecases, but without graphical user interface.</li> </ol> <p>DigiDoc4 client application is not in the scope of CDOC2 system, even though, it is the main client application, through which the end-user actually uses the system use-cases.</p>"},{"location":"03_system_architecture/ch01_system_context/#external-systems","title":"External Systems","text":"<p>There are other components, which are supporting CDOC2 system in some way:</p> <ol> <li>CDOC2 authentication portal, which issues long term access tokens to MID/SID proxy.</li> <li>MID/SID authentication services proxy, which relays the MID/SID authentication requests to actual Mobile-ID/Smart-ID RP-API services. TARA, which is a EE government provided central authentication service, used by CDOC2 authentication portal</li> <li>OCSP and LDAP services, which provide ID-card/MID/SID certificate validity and certificate search services.</li> </ol>"},{"location":"03_system_architecture/ch02_system_components/","title":"CDOC2 system components","text":""},{"location":"03_system_architecture/ch02_system_components/#cdoc2-reference-java-library","title":"CDOC2 reference Java library","text":"<p>Implements client side functionality for CDOC2 system.</p>"},{"location":"03_system_architecture/ch02_system_components/#cdoc2-capsule-server-ccs","title":"CDOC2 Capsule Server (CCS)","text":"<p>Stores encryption/decryption key material. Provides endpoints for auth-ticket creation and key material upload/download. For SID/MID use cases key material is distributed between multiple CDOC2 servers instances, so that compromising one server doesn't expose key material. Instances run on independent premises.</p>"},{"location":"03_system_architecture/ch02_system_components/#authentication-proxy","title":"Authentication proxy","text":"<p>A server that relays the Mobile-ID and Smart-ID authentication requests to actual Mobile-ID/Smart-ID RP API services and acts as relying party (RP). Generates and stores secrets that cannot be revealed to CDOC2 Client Applications.</p>"},{"location":"03_system_architecture/ch02_system_components/#cdoc2-cli-user-application","title":"CDOC2 CLI user application","text":"<p>Command line utility to create/process CDOC2 files. Provides CLI interface to CDOC2 reference Java library.</p>"},{"location":"03_system_architecture/ch02_system_components/#interfaces-between-system-components","title":"Interfaces between system components","text":""},{"location":"03_system_architecture/ch02_system_components/#cdoc2-capsule-server-ccs-interface","title":"CDOC2 Capsule Server (CCS) interface","text":"<p>TODO: Add existing endpoints</p> <p>New endpoints for shared secrets supporting SID/MID:</p> <ul> <li>/shared-secrets Upload Shamir Secret Share and get transactionId</li> <li>/shared-secrets/{transactionId}/nonce   Create nonce for transactionId (for authentication). Authentication ticket creation schema</li> <li>/shared-secrets/{transactionId} GET Shamir Shared Secret for transactionId</li> </ul>"},{"location":"03_system_architecture/ch03_external_interfaces/","title":"External components and services","text":"<p>This section will describe, how CDOC2 system is using external components and services</p>"},{"location":"03_system_architecture/ch03_external_interfaces/#midsid-authentication-proxy","title":"MID/SID authentication proxy","text":"<p>Proxy provided by RIA to provide access to Smart-ID RP API and Mobile-ID REST API</p>"},{"location":"03_system_architecture/ch03_external_interfaces/#smart-id-rp-api","title":"Smart-ID RP API","text":"<p>Relaying Party API is used to start authentication with Smart-ID accessed through MID/SID authentication proxy</p> <ul> <li>/authentication   Starts authentication with Smart-ID</li> <li>/session   Poll authentication status</li> </ul>"},{"location":"03_system_architecture/ch03_external_interfaces/#mobile-id-rest-api","title":"Mobile-ID REST API","text":"<p>TODO</p>"},{"location":"03_system_architecture/ch03_external_interfaces/#ldap-and-ocsp-servers","title":"LDAP and OCSP servers","text":"<ul> <li>LDAP: (https://www.skidsolutions.eu/resources/ldap/)</li> <li>OCSP: SK validity confirmation service is described here and here.</li> </ul>"},{"location":"03_system_architecture/ch03_external_interfaces/#smart-id-app","title":"Smart-ID app","text":"<p>Enables to authenticate and sign using Smart-ID. Installed on user smartphone.</p> <p>(https://www.smart-id.com/et/laadi-alla/)</p>"},{"location":"03_system_architecture/ch03_external_interfaces/#mobile-id-sim-application","title":"Mobile-ID SIM application","text":"<p>TODO</p>"},{"location":"03_system_architecture/ch04_capsule_server/","title":"CDOC2 CSS","text":"<p>This section defines the CDOC2 CSS (CCS, herein also simply \u2018the server\u2019), what interfaces it provides to other system components and rules of use.</p>"},{"location":"03_system_architecture/ch04_capsule_server/#introduction","title":"Introduction","text":"<p>The CCS is a subsystem tasked with transmitting the Capsule required for the decryption of the CDOC2 Container from the sender to the recipient following the rules set out for specific encryption methods in section CDOC2 encryption schemes. In some cases the encryption schemes use single CCS and in some cases, encryption schemes use multiple CCSs, which are independent and operated by separate organizations.</p> <p>The communication channel provided by the CCS (or multiple CCSs) is more secure than public channels of communication used for the transmission of CDOC2 Containers. A properly operating CCS ensures that the attacker, who is monitoring the public communication channel and may store all CDOC2 Containers and may be able to break public key encryption algorithms in the future with sufficiently powerful quantum computer, is not able to do so, because the Capsule information is transmitted in a separate channel. Thus the CDOC2 System gains some additional protection against quantum computers. The CCS does not need to transmit large encrypted documents, meaning that its operating costs will be low.</p> <p>Multiple CCSs may be used in parallel, operated by different organizations. Security requirements established in the implementation process may call for the operation of each individual CCS by organizations, that are independent from each other.</p>"},{"location":"03_system_architecture/ch04_capsule_server/#ccs-operating-principles","title":"CCS operating principles","text":"<p>In the simplest case, the CCS operates as follows.</p> <ol> <li>The Sender generates a Capsule for a specific Recipient during encryption.</li> <li>The Sender chooses a CSS, connects to the server and transmits the Capsule to the server along with a Recipient identifier.</li> <li>The CSS generates a transaction identifier and saves the generated identifier along with the Capsule and Recipient identifier.</li> <li>The sender adds the selected server\u2019s identifier, transaction identifier, and recipient identifier to the container.</li> <li>The sender transmits the container to the recipient.</li> <li>The recipient finds information concerning the Capsule generated for them in the container.</li> <li>The recipient connects to the server chosen by the sender and authenticates with the server.</li> <li>The recipient transmits the transaction identifier found in the container to the server.</li> <li>The server looks up the Capsule based on the transaction identifier and the recipient identifier established during authentication.</li> <li>The server returns the Capsule to the recipient.</li> <li>The recipient uses the information found in the Capsule for decrypting the container.</li> </ol> <p>TODO: this diagram doesn't match the steps yet.</p> <p></p>"},{"location":"03_system_architecture/ch04_capsule_server/#server-state","title":"Server state","text":"<p>Server state consists of the Capsules received by the server for transmission, as well as all relevant information.</p> <ul> <li>Capsule: Byte array, meaningless for the server.</li> <li>Transaction ID: UUID generated by the server itself using a cryptographically secure random number generator.</li> <li>Recipient ID: Identifier received by the server as the output of the recipient authentication process.</li> <li>Validity period: The CSS stores the Capsule only for a limited period, collectively specified by the sender and the key management policies used by the CSS. The capsule is deleted after this period.</li> </ul>"},{"location":"03_system_architecture/ch04_capsule_server/#server-interfaces","title":"Server interfaces","text":"<p>The server provides two interfaces: one for delivery of the Capsule from the sender to the CSS and the other for delivery of the Capsule from the server to the recipient.</p> <p>The interfaces are formally described in the OpenAPI format (see appendix C).</p>"},{"location":"03_system_architecture/ch04_capsule_server/#sender-interface","title":"Sender interface","text":"<p>The CSS sender interface is used by the sender to transmit the Capsule to the server and receive a transaction identifier that they will subsequently add to the container header.</p> <p>The sender transmits the Capsule and recipient identifier to the server and receives from the server a transaction identifier. The interface is unauthenticated and can be used by all senders.</p>"},{"location":"03_system_architecture/ch04_capsule_server/#recipient-interface","title":"Recipient interface","text":"<p>The CSS recipient interface is used by the recipient to receive a Capsule from the server.</p> <p>The recipient authenticates with the server and transmits a transaction identifier. Based on this identifier, the server looks up the Capsule. The capsule must be addressed to the recipient who authenticated with the server \u2013 the server thus compares the recipient identifier established during authentication with the recipient identifier transmitted by the sender of the Capsule. The server then returns the Capsule to the recipient.</p>"},{"location":"03_system_architecture/ch04_capsule_server/#interface-security","title":"Interface security","text":"<p>Interface security is ensured using the TLS 1.3 protocol. The server holds a certificate issued by a publicly available and trusted CA. The clients can validate this certificate on each connection using the OCSP protocol.</p> <p>To ensure protocol security, it is important to make sure that the Capsule is only received by the CSS. This can be achieved via the pinning of server TSL keys. Key pinning ensures that commonly practiced1 use of TLS inspection does not compromise the confidentiality of the keying material.</p>"},{"location":"03_system_architecture/ch04_capsule_server/#server-identification-and-trust","title":"Server identification and trust","text":"<p>Enhanced security features provided by CDOC2 are only valid if the Capsule is transmitted via servers meeting the requirements of the specific encryption scenario (see section 3. TODO link?).</p> <p>To ensure the recipient and sender\u2019s confidence in the servers they are using, each client using the CDOC2 format must be provided with a list of trusted CSSs either as a part of the DigiDoc software package or in some other form. This list is also used for TLS key pinning.</p> <p>The server list consists of the following elements.</p> <ul> <li>Server identifier</li> <li>Capsule type supported by the server.</li> <li>Sender interface URL.</li> <li>Recipient interface URL.</li> <li>Identifier of the organization maintaining the server.</li> <li>Server public keys to enable the client to cryptographically verify the server\u2019s identity. Public keys are provided in the form of certificates.</li> </ul> <p>The sender never transmits the recipient the server\u2019s technical access point but only its identifier in the server list. This is done to prevent attacks seeking mislead the recipient into communicating with an untrusted server.</p> <p>Should multiple independent CSS infrastructures be set up with no coordination of server identifier assignation between the systems and should the same identifier be assigned to different servers in different systems, this could lead to a situation where a client using the infrastructure of one system creates a container that another client will then attempt to open using the infrastructure of another system.</p> <p>This would result in the recipient contacting the wrong CSS, authenticating with the server, and transmitting the transaction identifier found in the container to the server. The server will be unable to find the Capsule corresponding to this transaction identifier and will return an error message (Decryption failed).</p> <p>The CSS used by the recipient will receive a transaction identifier but since it will be unable to authenticate with the correct CSS on the behalf of the recipient, it will also be unable to download the Capsule from the correct server.</p> <p>The Capsule type supported by the server allows the sender to choose the correct Capsule type and enables the recipient to authenticate with the server using the correct protocol. As the servers are lightweight, an organization seeking to support multiple different recipient types will be able to run multiple separate CSSs. This ensures that the CSSs can be simplified and thus made more secure. This is especially important in the case of the recipient interface, as the authentication protocols used may widely differ in their features, making secure implementation difficult.</p> <p>The identifier of the organization maintaining the server does not necessarily have to be explicitly tied to the organization\u2019s name, but it must enable the identification of servers controlled by the same organization. This information is required to support future secret sharing-based encryption methods.</p> <p>Each server may be assigned more than one public key \u2013 this helps ensure smooth change of certificates and keys. Upon connection to the server, the client must always verify that the server is using one of the listed certificates. This will help prevent man-in-the-middle attacks.</p>"},{"location":"03_system_architecture/ch04_capsule_server/#recipient-authentication","title":"Recipient authentication","text":"<p>Each CSS-based Capsule type describes a specific recipient identification and authentication method. This version of the specification defines two CSS-based Capsule types:</p> <ol> <li><code>KeyServerCapsule</code> -- public key based authentication and access control</li> <li><code>KeySharesCapsule</code> -- national identity code based authentication and access control</li> </ol> <p>This list may be expanded in future versions of the specification. Various authentication schemes may be used in parallel.</p>"},{"location":"03_system_architecture/ch04_capsule_server/#the-keyservercapsule-authentication-scheme","title":"The <code>KeyServerCapsule</code> authentication scheme","text":"<p>In this scheme, the recipient is identified by their public key used for the decryption of the container. The public key is defined by the field <code>RecipientKey</code> in the structure <code>KeyServerCapsule</code>.</p> <p>The server authenticates the recipient using TLS client authentication (mTLS). The server is configured to validate the client certificate (e.g. using OSCP). Should the recipient lose control of their decryption key and cancel their certificate, the CSS will not issue the Capsule card to the new holder (potential attacker) and the attacker will be unable to decrypt the container.</p> <p>After successful authentication, the server reads the client\u2019s public key from the certificate used by the client and compares this public key to the public key tied to the Capsule referenced by the transaction identifier. If the two keys match, the server will return the Capsule. Otherwise, the server will return an error message.</p>"},{"location":"03_system_architecture/ch04_capsule_server/#the-keysharescapsule-authentication-scheme","title":"The <code>KeySharesCapsule</code> authentication scheme","text":"<p>In this scheme, the recipient is identified by the national identity code (isikukood). Identity code of the recipient is defined by the field <code>recipient_id</code> in the structure <code>KeySharesCapsule</code>.</p> <p>The server authenticates the recipient using a special protocol, as described in section ID authentication protocol.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/","title":"ID authentication protocol","text":"<p>This section describes a protocol and data formats for authenticating to multiple CSS servers (cdoc2-shares-servers) in order to download every <code>KeySharesCapsule</code> from them.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#authentication-protocol-requirements","title":"Authentication protocol requirements","text":"<ol> <li>Multiple CSSs hold Capsules, which all need to be downloaded by Client.</li> <li>Client needs to authenticate to multiple CSSs, in order to download all Capsules.</li> <li>Client should only need to create one signature with its authentication means (ID-card, Mobile-ID, Smart-ID) for authentication.</li> <li>CSS must not be able to replay the authentication ticket to another CSS.</li> </ol>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#non-suitable-alternatives","title":"Non-suitable alternatives","text":"<p>Before designing a custom authentication protocol, we should make sure that this is really needed and we cannot re-use existing protocols. Existing protocols may already have proven security properties and they might be well supported by existing software libraries.</p> <p>For example, traditionally, authentication and authorization processes are handled by OpenID Connect and OAuth2 protocols. They are well studied and robust. However, if we try to apply them to our situation and try to map the mandatory roles from OpenID Connect and OAuth2 ecosystems to our components (Client, CSSs), it becomes cumbersome.</p> <p>First, the requirement that Client needs to \"login\" to multiple servers with single use of user's eID means is tricky. This is usually handled by single-sign-on services. There's such a service called GovSSO (https://e-gov.github.io/GOVSSO/TechnicalSpecification), but it is more oriented towards web applications and it is using a generic OpenID Connect protocol without binding the issued <code>id_tokens</code> with user's authentication signatures. In case CSS would be accepting such <code>id_tokens</code>, there's no cryptographic guarantee that the user's authentication has actually taken place and that the user's eID means was actually involved. That would mean that the security of such central single-sign-on provider would be critical and in case the security of GovSSO would be breached, it would be able to download all KeyShares on behalf of any user.</p> <p>Additionally, if we would be using OAuth2 authorization protocols, we would be using OAuth2 \"bearer\" tokens and this would mean that CSS server can re-use the token and replay it to another CSS server. Possibility to replay tokens might be overcome with protocols like \"OAuth2 Certificate-Bound Access Tokens\" (https://datatracker.ietf.org/doc/html/rfc8705) and \"OAuth2 Demonstrating Proof of Possession\" (https://www.rfc-editor.org/rfc/rfc9449), but that would require us to create a central trusted component which would hand out those access tokens. That kind of component would be a single source of failure and in case the security of such component would be breached, the attacker would be able to download all KeyShares on behalf of any user.</p> <p>Therefore, introducing additional trusted components to the CDOC2 ecosystem is not desirable at the moment. More tailored approach would be needed to come up with authentication protocol, that would satisfy all the requirements and would depend only on the eID authentication means or eID trust service providers.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#overview-of-the-generic-authentication-protocol","title":"Overview of the generic authentication protocol","text":"<p>In the generalized form, the authentication protocol for downloading a Capsule information from servers can be explained with the following sequence diagram below.</p> <p>This is just an abstract overview of the authentication protocol. In the next sections, we describe what kind of data is used as the authentication data, how the eID means signing function is used and how only a minimal set of authentication data is revealed to each CSS server, in order to prevent replay.</p> <p></p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#sd-jwt-based-cdoc2-authentication-protocol","title":"SD-JWT based CDOC2 authentication protocol","text":"<p>In this section the details of the authentication protocol are explained.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#authentication-data","title":"Authentication data","text":"<p>In the generic protocol, there's a idea that Client signs a set of information, which expresses the proof of Recipient's identity and intent to download specific Capsule information. We will use the JWT standard (https://www.rfc-editor.org/rfc/rfc7519.html). Client will sign the following set of JWT claims with their authentication means (ID- card, Mobile-ID, Smart-ID), using the authentication key pair.</p> <pre><code>{\n    \"iss\": \"etsi/PNOEE-48010010101\",\n    \"aud\": [ \n            \"https://CSS.example-org1.ee:443/key-shares/9EE90F2D-D946-4D54-9C3D-F4C68F7FFAE3?nonce=59b314d4815f21f73a0b9168cecbd5773cc694b6\", \n            \"https://CSS.example-org2.ee:443/key-shares/5BAE4603-C33C-4425-B301-125F2ACF9B1E?nonce=9d23660840b427f405009d970d269770417bc769\"\n        ]\n}\n</code></pre> <p>If the Client would create (in JWT and SD-JWT terminology, \"issue\") an ordinary signed JWT with these claims, the resulting thing would look something like that:</p> <pre><code>eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9\n.\neyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFtcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n.\ndBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n</code></pre> <p>It contains following sections, separated by periods (\".\"):</p> <ol> <li>first section is base64-encoded JOSE header (for example <code>{\"typ\":\"JWT\", \"alg\":\"HS256\"}</code>)</li> <li>second section is base64-encoded JWT claims</li> <li>third section is base64-encoded signature value</li> </ol> <p>It is not possible to modify the JWT claims anymore and to leave out some values from the \"aud\" claim, in order to not reveal the nonce values to some CSS servers and to prevent the replay possibility.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#intro-to-sd-jwt-standard","title":"Intro to SD-JWT standard","text":"<p>SD-JWT standard (https://sdjwt.js.org, https://datatracker.ietf.org/doc/draft-ietf-oauth-selective-disclosure-jwt/) defines a mechanism for selective disclosure of individual elements of a JSON object used as the payload of a JSON Web Signature (JWS) structure. It assumes a ecosystem with following entities:</p> <ol> <li>SD-JWT is created by an entity called Issuer. Issuer decides, what claims are included in SD-JWT and which claims are individually disclosable. Issuer signs the SD-JWT with its key pair and this way secures the SD-JWT against modifications.</li> <li>SD-JWT is received from Issuer by entity called Holder. Holder decides when and where to present the SD-JWT and also decides, which disclosable claims it wishes to reveal and which one it wishes to keep secret.</li> <li>SD-JWT is presented to an entity called Verifier. Verifier requests SD-JWT from Holder, checks the Issuer signature and extracts the list of claims from SD-JWT.</li> </ol> <p>We are mapping those SD-JWT-specific entities to CDOC2 world in the following way:</p> <ol> <li>SD-JWT data structure is used as both CDOC2 authentication data and CDOC2 authentication signature. In other words, information that is used to create authentication data and authentication signature, is expressed (encoded) as SD-JWT structure. Authentication signature corresponds to Issuer signature.</li> <li>SD-JWT presentation with selectively disclosed claims is used as server-specific CDOC2 authentication ticket.</li> <li>Roles of SD-JWT Issuer and SD-JWT Holder is performed by CDOC2 Client. Client creates the SD-JWT structure, specifies that some claims are disclosable and later creates specific presentations to each CSS server. SD-JWT standard optionally supports the scenario when Holder has its own key pair (separate from Issuer's key pair) and it is possible to verify this key binding during the SD-JWT presentations. In CDOC2 system, we don't use Holder's key binding feature.</li> <li>Role of SD-JWT Verifier is performed by CSS servers. Servers will provide Client with nonces and verify that they will receive a valid signed SD-JWT with server-specific nonce as disclosable claim.</li> </ol>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#sd-jwt-and-selective-disclosures","title":"SD-JWT and selective disclosures","text":"<p>How does this \"selective disclosure\" feature actually work behind the scenes? The idea is that Issuer will create special kind of <code>SD-CLAIMS</code> data items in the ordinary JWT, which are:</p> <pre><code>SD-CLAIMS = (\n    CLAIM-NAME: HASH(SALT | CLAIM-VALUE)\n)*\n</code></pre> <p>where <code>SALT</code> is a random salt. This kind of operation effectively \"hides\" the content of the <code>CLAIM-VALUE</code>. But, it allows Verifier to check if the digest was computed from the correct value, if he is provided with the salt and clear-text claim value. Such kind of <code>SD-CLAIMS</code> are included in the JWT structure, in a special claim with name <code>_sd</code>.</p> <p>In order to reveal the <code>CLAIM-VALUE</code> to Verifier, Holder needs to create <code>SD-RELEASES</code> data items, which are:</p> <pre><code>SD-RELEASES = (\n    CLAIM-NAME: (DISCLOSED-SALT, DISCLOSED-VALUE)\n)\n</code></pre> <p>and include such info in the JWT, in a special claim with name <code>sd_release</code>. So, for example, if the original set of claims are following:</p> <pre><code>{\n  \"sub\": \"6c5c0a49-b589-431d-bae7-219122a9ec2c\",\n  \"given_name\": \"John\",\n  \"family_name\": \"Doe\",\n}\n</code></pre> <p>Let's say that the Issuer wishes to make claim <code>given_name</code> disclosable. It generates a random salt and computes digest value from <code>SHA-256(\"eluV5Og3gSNII8EYnsxA_A\" + \"John\")</code> and includes such <code>SD_CLAIM</code> data item in the <code>_sd</code> claim:</p> <pre><code>{\n  \"sub\": \"6c5c0a49-b589-431d-bae7-219122a9ec2c\",\n  \"family_name\": \"Doe\",\n  \"_sd_\": {\n    \"given_name\": \"PvU7cWjuHUq6w-i9XFpQZhjT-uprQL3GH3mKsAJl0e0\"\n  }\n}\n</code></pre> <p>This JOSE is then signed as <code>&lt;JWT_payload</code> and following JWT is created:</p> <pre><code>&lt;JWT_header&gt;.&lt;JWT_payload&gt;.&lt;JWT_signature&gt;\n</code></pre> <p>However, this \"compact\"-encoded JWT doesn't yet contain random salt values. So, SD-JWT Salt/Value Container, which is simply a JSON array of <code>SD-RELEASES</code> data items, is also added:</p> <pre><code>{ \n  [\n    \"given_name\": \"[\\\"eluV5Og3gSNII8EYnsxA_A\\\", \\\"John\\\"]\",\n  ]\n}\n</code></pre> <p>and it is encoded in Base64 and added to the original encoded JWT, after yet another period (\".\"):</p> <pre><code>&lt;JWT_header&gt;.&lt;JWT_payload&gt;.&lt;JWT_signature&gt;.&lt;SD-JWT Salt/Value Container&gt;\n</code></pre> <p>Now, Holder can decide which disclosable claim information from the Salt/Value Container it will include, when creating a presentation to Verifier, and which it removes. The signature of the original JWT is still valid, because original JWT will be unchanged.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#creating-sd-jwt-structure-authentication-data-and-authentication-signature","title":"Creating SD-JWT structure (authentication data and authentication signature)","text":"<p>Applying SD-JWT data structure to the CDOC2 authentication protocol situation, we will reach the following specification:</p> <ol> <li>Client creates an SD-JWT with following example header:</li> </ol> <pre><code>{\n    \"typ\": \"vnd.cdoc2.auth-token.v1+sd-jwt\",\n    \"alg\": \"ES256\",\n    \"kid\": \"PNOEE-48010010101\"\n}\n</code></pre> <p>The values for the \"alg\" claim depend on the signature algorithm that the user's eID means authentication key pair is using. For example, the ID-card produces signatures with ES256 algorithm, Smart-ID produces signatures with RS256 algorithm.</p> <ol> <li>Client initialises empty SD-JWT payload structure and adds always-disclosed claims to SD-JWT payload. Examples is provided here. Note that the <code>aud</code> claim contains only empty array at the moment.</li> </ol> <pre><code>{\n    \"aud\": [],\n    \"iss\": \"etsi/PNOEE-48010010101\"\n}\n</code></pre> <ol> <li>Client adds disclosable JSON strings to the array <code>aud</code> for each CSS server. For example, the <code>aud</code> claim may contain following StringOrURI values:</li> </ol> <pre><code>[\n    \"https://CSS.example-org1.ee:443/key-shares/9EE90F2D-D946-4D54-9C3D-F4C68F7FFAE3?nonce=59b314d4815f21f73a0b9168cecbd5773cc694b6\", \n    \"https://CSS.example-org2.ee:443/key-shares/5BAE4603-C33C-4425-B301-125F2ACF9B1E?nonce=9d23660840b427f405009d970d269770417bc769\"\n]\n</code></pre> <ol> <li>Client signs the SD-JWT structure as SD-JWT Issuer with the user's authentication means.</li> </ol>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#presenting-sd-jwt-creating-authentication-ticket","title":"Presenting SD-JWT (creating authentication ticket)","text":"<p>For each server, Client creates SD-JWT presentation and discloses only that <code>aud</code> array element, which contains the <code>key-share</code> and <code>nonce</code>, which is specific to that server.</p> <p>Resulting SD-JWT is formatted as (elements separated by \"~\"):</p> <pre><code>&lt;Issuer-signed JWT&gt;~&lt;Disclosure 1&gt;~\n</code></pre> <p>where <code>&lt;Issuer-signed JWT&gt;</code> contains following elements (separated by \".\"):</p> <pre><code>&lt;SD-JWT header&gt;.&lt;SD-JWT payload&gt;.&lt;Issuer signature&gt;\n</code></pre> <p>Actual SD-JWT in compact representation looks something like that: <pre><code>eyJhbGciOiAiRVMyNTYiLCAidHlwIjogImV4YW1wbGUrc2Qtand0IiwgIng1YyI6ICJNSUlDOFRDQ0FkbWdBLi4uVnQ1NDMyR0E9PSJ9.eyJfc2QiOiBbIjFTVGpGbEJINmptRjI3MElmeTJTdFhuTXpaMlREcklLSlg1Qnk2NWd2LTQiXSwgImlhdCI6ICIxNzE1Njk0MjUzIiwgImV4cCI6ICIxNzE1Njk0MjYzIiwgIl9zZF9hbGciOiAic2hhLTI1NiJ9.0EXb6QCwNL19ZWieDHDWZsm2W_bO2tCH8QBr1ftcTFh2t2P77qEimYjrattAHMah5FPAD3otdDARzh4DfWcuVg~WyJrLTRFYVpwQWctMTdRbk1mT3dNYk93IiwgInNoYXJlQWNjZXNzRGF0YSIsIFt7Ii4uLiI6ICJFRXNfNWVmWUN5WVNjaDB6ZTJKZ1VsV0VpSVhzcTZic1o4UXFBdnlqZXVNIn0sIHsiLi4uIjogIkZfLTZuc0RDT0NvSmNOS2ZhODdWZ0FNVFRzODdLRjN6WXlzbUpnQzF3ckUifV1d~WyJMUTN0eUxONHZVbDRFakR0ekdmRVFnIiwgeyJzZXJ2ZXJCYXNlVVJMIjogImh0dHBzOi8vY2RvYy1jY3MucmlhLmVlOjQ0My9rZXktc2hhcmVzLyIsICJzaGFyZUlkIjogIjlFRTkwRjJELUQ5NDYtNEQ1NC05QzNELUY0QzY4RjdGRkFFMyIsICJzZXJ2ZXJOb25jZSI6ICI0MiJ9XQ~\n</code></pre></p> <p>if we decode the individual parts, we get the following pieces.</p> <ol> <li>Protected header:</li> </ol> <pre><code>{\n    \"alg\": \"ES256\",\n    \"typ\": \"vnd.cdoc2.auth-token.v1+sd-jwt\",\n}\n</code></pre> <ol> <li>Protected payload:</li> </ol> <pre><code>{\n    \"_sd\": [\n        \"1STjFlBH6jmF270Ify2StXnMzZ2TDrIKJX5By65gv-4\"\n    ],\n    \"_sd_alg\": \"sha-256\"\n}\n</code></pre> <ol> <li>Binary signature:</li> </ol> <pre><code>0EXb6QCwNL19ZWieDHDWZsm2W_bO2tCH8QBr1ftcTFh2t2P77qEimYjrattAHMah5FPAD3otdDARzh4DfWcuVg\n</code></pre> <ol> <li>Salt/Value Container with salts and hashes:</li> </ol> <pre><code>[\n    \"k-4EaZpAg-17QnMfOwMbOw\",\n    \"aud\",\n    [\n        ...\n    ]\n]\n</code></pre> <ol> <li>Disclosures:</li> </ol> <pre><code>[\n    \"LQ3tyLN4vUl4EjDtzGfEQg\",\n    {\n        ...\n    }\n]\n</code></pre>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#verifying-sd-jwt-verifying-authentication-ticket","title":"Verifying SD-JWT (verifying authentication ticket)","text":"<p>CSS server receives the compact SD-JWT presentation (<code>&lt;Issuer-signed JWT&gt;~&lt;Disclosure 1&gt;~</code>) and performs following authentication and authorization checks:</p> <ol> <li>Verify that SD-JWT is signed by the key pair, whose public key is included in the X.509 certificate, which is transmitted in the API method \"GET /key-shares/{shareId}\" parameter \"x-cdoc2-auth-x5c\".</li> <li>Verify that certificate is issued by trustworthy CA.</li> <li>Verify that certificate is valid at current point of time and is not revoked.</li> <li>Verify that SD-JWT contains claim <code>aud</code>, which is an array, which contains exactly one JSON string.</li> <li>Parse the <code>aud</code> value (something like \"https://CSS.example-org1.ee:443/key-shares/9EE90F2D-D946-4D54-9C3D-F4C68F7FFAE3?nonce=59b314d4815f21f73a0b9168cecbd5773cc694b6\") into components <code>serverBaseURL</code>, <code>shareId</code> and <code>nonce</code>.</li> <li>Verify that <code>serverBaseURL</code> is correct for this CSS server.</li> <li>Verify that this CSS server has a Capsule with identifier <code>shareId</code> and it is not expired or deleted.</li> <li>Verify that this CSS server has previously generated a nonce for this <code>shareId</code> and the stored nonce value matches with <code>nonce</code> component value and that nonce wasn't generated too long ago (configuration parameter, for example 300 seconds).</li> <li>Verify that <code>recipient_id</code> from the <code>KeySharesCapsule</code> matches with the <code>subjectDN</code> from the X.509 certificate from API parameter \"x-cdoc2-auth-x5c\".</li> </ol> <p>If all checks are positive, then the authentication and access control decision is successful and CSS server can return the capsule.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#security-of-the-protocol","title":"Security of the protocol","text":"<p>We are analyzing security of the authentication protocol from the following aspects.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#protection-against-the-passive-network-read","title":"Protection against the passive network read","text":"<p>In case the network between the CDOC2 Client and CSS servers is compromised and attacker is able to read network connections, the attacker is simply able to observe the values of the capsule shares as they are downloaded from CSS servers. The authentication protocol itself doesn't have built-in protection against this and assumes that connections from CDOC2 Client to every CSS server are authenticated and transmission is encrypted with HTTPS protocol.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#protection-against-the-mitm-attack-with-connection-hijacking","title":"Protection against the MITM attack with connection hijacking","text":"<p>In case the attacker is able to hijack the network connections between the CDOC2 Client and CSS servers and redirect the connection attempts from the real CSS servers to attacker itself, attacker is also able to masquerade to Client as real CSS server and is also observe the values of the transmitted capsule shares. Attacker might be able to present a self-signed X.509 HTTPS certificate or it might be able to present a valid X.509 HTTPS certificate from the real CA as well. In case the CDOC2 Client doesn't verify the identity of the CSS server, it is not able to tell a difference between the attacker and real CSS server.</p> <p>It is essential that CDOC2 Clients authenticate, which servers they are connecting to and that they are verifying the HTTPS X.509 certificates against the whitelisted values in the configuration file.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#protection-against-compromised-css-servers","title":"Protection against compromised CSS servers","text":"<p>In case the attacker has compromised some of the CSS servers, the following attack scenario should be considered.</p> <ol> <li>Client connects to CSS-1 and asks for nonce <code>nonce1</code>. CSS-1 is controlled by attacker and they return the value of <code>nonce1</code>.</li> <li>Client connects to CSS-2 and asks for nonce <code>nonce2</code>. CSS-2 is secure and returns the value of <code>nonce2</code>.</li> <li>Client creates authentication signature, in the form of issuing SD-JWT.</li> <li>Client creates presentation of SD-JWT for CSS-1 with the disclosure of the value of <code>nonce1</code> and sends this to CSS-1. The value of <code>nonce2</code> is not revealed.</li> <li>Attacker uses the signed SD-JWT and tries to create another presentations for CSS-2. However, since the attacker doesn't know the salt value and clear-text value of the second component of the <code>aud</code> claim, it is not able to create valid presentation.</li> </ol> <p>Therefore, the protocol is secure against compromise of some CSS servers.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#protection-against-css-server-compromise-and-nonce-reuse","title":"Protection against CSS server compromise and nonce reuse","text":"<p>In case the attacker has compromised some of the CSS servers and tries to confuse Client by mixing nonces from different servers, the following attack scenario should be considered.</p> <ol> <li>Attacker has knowledge of all capsule share identification values, <code>shareId1</code> and <code>shareId2</code>, for example, from the captured CDOC2 container.</li> <li>Client connects to CSS-1 and asks for nonce value of the <code>shareId1</code>. CSS-1 is controlled by attacker and instead of returning freshly generated <code>nonce1</code>, attacker connects to CSS-2 and asks for the nonce value of the <code>shareId2</code> and returns this as <code>nonce2_1</code> to Client.</li> <li>Client connects to CSS-2 and asks for nonce value of the <code>shareId2</code>. CSS-2 generates another <code>nonce2_2</code> and returns this to Client.</li> <li>Client creates authentication signature, in the form of issuing a SD-JWT.</li> <li>Client creates presentation of SD-JWT for CSS-1 with the disclosure of the value of <code>nonce2_1</code> and sends this to CSS-1. The value of <code>nonce2_2</code> is not revealed.</li> <li>Attacker takes the SD-JWT presentation and replays it to CSS-2. Because it contains the value of <code>nonce2_1</code>, which is generated by CSS-2, attacker is hoping that CSS-2 responds with value of the capsule share.</li> <li>CSS-2 verifies that <code>nonce2_1</code> is associated with the wrong share identifiers, <code>shareId1</code>, which doesn't match with the share identifier that CSS-2 has and denies the request.</li> </ol> <p>Therefore, the protocol is secure against compromise of some CSS servers, which might be trying mixing and reusing nonces.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#protection-against-dos-attacks","title":"Protection against DOS attacks","text":"<p>Protocol doesn't have a built-in protection against DOS attacks. When deploying CDOC2 system components, components in the network infrastructure, such as load balancers or application servers need to use DOS protection mechanisms, such as limiting the number of service requests from single IP-address or others.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#formal-analysis","title":"Formal analysis","text":"<p>Even though we have carefully designed the protocol with security requirements in mind and it has been reviewed multiple times and it includes protection against common network attacks, we are not able to proove the security of the solution. </p> <p>However, we can increase the confidence by using formal analysis methods. We have implemented the protocol flow as a model of ProVerif (https://bblanche.gitlabpages.inria.fr/proverif/) tool. ProVerif is an automated verification tool for cryptographic protocols, which works in the formal logic model Dolev-Yao and can mathematically verify and prove, if the protocol has some security properties, such as confidentiality, authentication, etc. Proving such properties may involve finding proof of not-existance of some other property and verification of all possible combinations. Therefore, using manual methods can be very time-consuming and doesn't usually give full confidence. </p> <p>Model has been presented in appendix A and it verifies the following properties.</p> <ol> <li>Described attacker is not able to download shares of capsules from CSS servers:</li> </ol> <pre><code>        Query not attacker(capsule[]) is true\n</code></pre> <ol> <li>Described attacker is not able to authenticate on behalf of the Client:</li> </ol> <pre><code>        Query event(FinishHandshake(x1,x2,x3,x4)) ==&gt; \n                event(StartHandshake(x1,x2,x3,x4)) is true.\n</code></pre> <p>Therefore, the described protocol should be secure against such properties. However, because ProVerif cannot analyse exactly the same CSS and CDOC2 Client source code. Therefore, there might be still unknown vulnerabilities in those areas. Still, this kind of additional formal analysis increases the confidence that protocol design doesn't have major security issues.</p>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#weakness-against-mitm-signature","title":"Weakness against MITM signature","text":"<p>In case the MITM attacker has been able to compromise the path between the CDOC2 Client and the user's authentication means (ID-card, Mobile-ID, Smart-ID) and is able to trick user to sign attacker's submitted hash with the user's authentication key pair, it is possible to attack the CDOC2 system. </p> <p>Following authentication means have this potential weakness:</p> <ol> <li>ID-card used over the interface PKCS#11</li> <li>Mobile-ID REST API</li> <li>Smart-ID RP-API v2</li> </ol> <p>Following authentication means or APIs (some of them are in development) do not have this weakness:</p> <ol> <li>ID-card used over the web-eID JS interface</li> <li>Smart-ID RP-API v3</li> </ol> <p>In order to mitigate against this weakness, CDOC2 system can benefit from following countermeasures:</p> <ol> <li>Informing the users about risks of using non-trusted software/services (desktop applications, mobile applications, websites). This countermeasures is already in use by practice.</li> <li>Vetting and limiting the RPs, who can use the Mobile-ID and Smart-ID APIs. This countermeasure is already used by practice.</li> </ol>"},{"location":"03_system_architecture/ch05_ID_authentication_protocol/#appendix-a-formal-model-for-authentication-protocol","title":"Appendix A - Formal model for authentication protocol","text":"<pre><code>(*************************************************************\nEsitame siinkohal v\u00e4ljapakutud autentimisskeemi \n(m\u00f5nev\u00f5rra lihtsustatud variandi) formaalse mudeli, mida on v\u00f5imalik \nProverif-iga (https://bblanche.gitlabpages.inria.fr/proverif/) anal\u00fc\u00fcsida.\n\nK\u00e4ivitamine:\nproverif -in pitype threeservers.pv\n**************************************************************)\n\nfree c: channel.\n\ntype host.\ntype nonce.\ntype pkey.\ntype skey.\ntype expc.\ntype dhpc.\ntype exps.\ntype dhps.\ntype transactionid.\n\nfun nonce_to_bitstring(nonce): bitstring [data,typeConverter].\n\n(* Signatures *)\n\nfun spk(skey): pkey.\nfun sign(bitstring, skey): bitstring.\nreduc forall m: bitstring, k: skey; getmess(sign(m,k)) = m.\nreduc forall m: bitstring, k: skey; checksign(sign(m,k), spk(k)) = m.\n\n(* Hash function *)\n\nfun h(bitstring) : bitstring.\n\n(* Secure channels *)\nfun gpowc(expc): dhpc.\nfun gpows(exps): dhps.\nfun mkChannelc1(expc, dhps): channel.\nfun mkChannels1(exps, dhpc): channel.\nfun mkChannelc2(expc, dhps): channel.\nfun mkChannels2(exps, dhpc): channel.\nequation forall x : expc, y : exps; \n    mkChannelc2(x, gpows(y)) = mkChannels2(y, gpowc(x)).\nequation forall x : expc, y : exps; \n    mkChannelc1(x, gpows(y)) = mkChannels1(y, gpowc(x)).\n\ntable honestUser(pkey).\ntable transidtable(exps, transactionid, nonce).\ntable honestServer(dhps).\n\n(* Queries *)\n\nfree capsule : bitstring [private].\nquery attacker(capsule).\n\nevent StartHandshake(pkey, dhps, channel, transactionid).\nevent FinishHandshake(pkey, dhps, channel, transactionid).\n\nquery x1 : pkey, x2 : dhps, x3 : channel, x4 : transactionid; \n    event(FinishHandshake(x1,x2,x3,x4)) ==&gt; \n        event(StartHandshake(x1,x2,x3,x4)).\n\n\nlet clientInstance(pkS1 : dhps, pkS2 : dhps, pkS3 : dhps, skME : skey) =\n  get honestServer(=pkS1) in\n  get honestServer(=pkS2) in\n  get honestServer(=pkS3) in\n  new transID1 : transactionid;\n  new transID2 : transactionid;\n  new transID3 : transactionid;\n  new chs1 : expc;\n  new chs2 : expc;\n  new chs3 : expc;\n  let cto1 = mkChannelc1(chs1, pkS1) in\n  let cfrom1 = mkChannelc2(chs1, pkS1) in\n  let cto2 = mkChannelc1(chs2, pkS2) in\n  let cfrom2 = mkChannelc2(chs2, pkS2) in\n  let cto3 = mkChannelc1(chs3, pkS3) in\n  let cfrom3 = mkChannelc2(chs3, pkS3) in ( (\n  !out(c, gpowc(chs1)) |\n  !out(cto1, transID1) |\n  !out(c, gpowc(chs2)) |\n  !out(cto2, transID2) |\n  !out(c, gpowc(chs3)) |\n  !out(cto3, transID3) \n  ) | (\n  in(cfrom1, challenge1 : nonce);\n  in(cfrom2, challenge2 : nonce);\n  in(cfrom3, challenge3 : nonce);\n  let tobesigned = (\n    (transID1, h(nonce_to_bitstring(challenge1))), \n    (transID2, h(nonce_to_bitstring(challenge2))),\n    (transID3, h(nonce_to_bitstring(challenge3)))) in\n  let tkt1 = (\n        (transID1, challenge1), \n        (transID2, h(nonce_to_bitstring(challenge2))), \n        (transID3, h(nonce_to_bitstring(challenge3)))) in\n  let tkt2 = (\n        (transID1, h(nonce_to_bitstring(challenge1))), \n        (transID2, challenge2), \n        (transID3, h(nonce_to_bitstring(challenge3)))) in\n  let tkt3 = (\n        (transID1, h(nonce_to_bitstring(challenge1))), \n        (transID2, h(nonce_to_bitstring(challenge2))), \n        (transID3, challenge3)) in\n  let smsg = sign(tobesigned, skME) in\n  new chs4 : expc;\n  new chs5 : expc;\n  new chs6 : expc;\n  let cto4 = mkChannelc1(chs4, pkS1) in\n  let cto5 = mkChannelc1(chs5, pkS2) in\n  let cto6 = mkChannelc1(chs6, pkS3) in\n  let pkME = spk(skME) in\n  ( (\n  event StartHandshake(spk(skME), pkS1, cto4, transID1);\n  (!out(c, gpowc(chs4)) | \n  !out(cto4, (tkt1, smsg, pkME)))\n  ) | (\n  event StartHandshake(spk(skME), pkS2, cto5, transID2);\n  (!out(c, gpowc(chs5)) |\n  !out(cto5, (tkt2, smsg, pkME)))\n  ) | (\n  event StartHandshake(spk(skME), pkS3, cto6, transID3);\n  (!out(c, gpowc(chs6)) |\n  !out(cto6, (tkt3, smsg, pkME)))\n  ) ) ) ).\n\nlet serverInstance1(sk : exps) =\n  in(c, dhc : dhpc);\n  let cfrom = mkChannels1(sk, dhc) in\n  let cto = mkChannels2(sk, dhc) in\n  in(cfrom, transID : transactionid);\n  new ch : nonce;\n  insert transidtable(sk, transID, ch);\n  out(cto, ch).\n\nlet serverInstance2(sk : exps) =\n  in(c, dhc : dhpc);\n  let cfrom = mkChannels1(sk, dhc) in\n  let cto = mkChannels2(sk, dhc) in\n  in(cfrom, (tkt : bitstring, msgsig : bitstring, userpk : pkey));\n  let ((tID1 : transactionid, v1 : bitstring), \n    (tID2 : transactionid, v2 : bitstring), \n    (tID3 : transactionid, v3 : bitstring)) = tkt in\n  ((\n    get transidtable(=sk, =tID1, v1prim) in\n    if nonce_to_bitstring(v1prim) = v1 then\n    let sgndmsg1 = ((tID1, h(v1)), (tID2, v2), (tID3, v3)) in\n    if checksign(msgsig, userpk) = sgndmsg1 then\n    get honestUser(=userpk) in\n    event FinishHandshake(userpk, gpows(sk), cfrom, tID1);\n    out(cto, capsule)\n  ) | (\n    get transidtable(=sk, =tID2, v2prim) in\n    if nonce_to_bitstring(v2prim) = v2 then\n    let sgndmsg2 = ((tID1, v1), (tID2, h(v2)), (tID3, v3)) in\n    if checksign(msgsig, userpk) = sgndmsg2 then\n    get honestUser(=userpk) in\n    event FinishHandshake(userpk, gpows(sk), cfrom, tID2);\n    out(cto, capsule)\n  ) | (\n    get transidtable(=sk, =tID3, v3prim) in\n    if nonce_to_bitstring(v3prim) = v3 then\n    let sgndmsg3 = ((tID1, v1), (tID2, v2), (tID3, h(v3))) in\n    if checksign(msgsig, userpk) = sgndmsg3 then\n    get honestUser(=userpk) in\n    event FinishHandshake(userpk, gpows(sk), cfrom, tID3);\n    out(cto, capsule)\n  )).\n\nlet mkHonestUser =\n  new s : skey;\n  let p = spk(s) in\n  insert honestUser(p);\n  out(c, p);\n  !(\n    in(c, (s1 : dhps, s2 : dhps, s3 : dhps));\n    clientInstance(s1, s2, s3, s)\n  ).\n\nlet mkHonestServer =\n  new s : exps;\n  let p = gpows(s) in\n  insert honestServer(p);\n  out(c, p);\n  ((!(\n    serverInstance1(s)\n  )) | (!(\n    serverInstance2(s)\n  ))).\n\nprocess\n  !mkHonestUser | !mkHonestServer\n</code></pre>"},{"location":"04_test_plan/test_plan/","title":"Purpose and scope of testing","text":"<p>The test plan presented herein describes tasks related to testing the CDOC2 capsule server (hereinafter also simply \u2018server\u2019). The test plan does not cover the client-side components of CDOC2; it is solely focused on the server side of the system.</p> <p>Within the scope of the test plan presented here, server testing serves two main purposes:</p> <ul> <li>Functional testing, to verify that the implemented functionality of the server is in line with what is prescribed in the documentation and the server can fulfil the established goals.</li> <li>Load testing, to establish the operation and behaviour of the server under different usage loads and patterns.</li> </ul>"},{"location":"04_test_plan/test_plan/#functional-testing","title":"Functional testing","text":"<p>The purpose of functional testing is to verify that the implemented functionality of the server is in line with what is prescribed in the documentation and the server can fulfil the established goals.</p> <p>Functional testing uses unit tests and automated API tests written by the developers that cover all scenarios described in server use cases and potential API error situations.</p>"},{"location":"04_test_plan/test_plan/#load-testing","title":"Load testing","text":"<p>Although no explicit requirements have been set out for server capability, it is important to be aware of the capacity limits of the developed software on a specific existing platform. This information is provided by load tests which seek answers to the following questions:</p> <ul> <li>What is the system\u2019s response time to users under different system loads?</li> <li>How many users can the system serve simultaneously without exceeding the defined response time?</li> <li>How will the system perform under extreme load conditions (e.g. very large number of simultaneous users or key shares in the database)?</li> <li>How will the system recover after peak load?</li> <li>How will the system perform under conditions of long-term moderate or higher load?</li> </ul>"},{"location":"04_test_plan/test_plan/#test-procedure-and-results","title":"Test procedure and results","text":"<p>Test planning is a continuous process, regularly repeated throughout the project after the addition of significant new information. The result of this process is the test plan (the present document).</p> <p>In the case of the capsule server, functional testing is covered by unit tests and API tests run against the server API.</p> <p>Unit tests are created by the developers and can be used by the development team, as well as in a continuous integration environment. The output of the tests is a human- and machine-readable test report. The source code for the unit tests is maintained along with the server\u2019s source code, following the same principles as the application source code.</p> <p>Just as the unit tests, the capsule server API tests are designed to be implementable as automatic tests to ensure the simplicity of running the tests and facilitate their repeatability. A test report on the unit tests run will be generated by the tool used.</p> <p>Tools for the development of API tests are chosen to ensure the simple maintenance of the developed tests, and the maintainability of their source code along with and following the same principles as the application source code.</p> <p>Tests used for establishing server capability are also implemented as automatic tests, utilizing a suitable testing tool. The best tool for this purpose will be determined during test development, considering the following requirements:</p> <ul> <li>Test development should not be unreasonably complex for the developer.</li> <li>Adjusting the desired load should not require software development skills.</li> <li>The resulting test report should be easily available and understandable.</li> </ul> <p>Note that the scope of load test development only includes the capability of stressing the system and the load tests do not include solutions for monitoring the system during load testing. Tools created for system monitoring must be used for this purpose.</p> <p>The result of load testing is a test report containing information on the questions covered in the corresponding section of the test plan. The report provides information on the loads applied to the server, as well as the usage of system resources (memory usage, processor load, storage usage) required for servicing queries.</p>"},{"location":"04_test_plan/test_plan/#designed-test-scenarios","title":"Designed test scenarios","text":"<p>Test ideas and scenarios are normally not explicitly covered in a test plan. However, as the capsule server is an application with limited functionality, there would be little need for a separate document for test scenario management. The present section also describes the scenarios designed to be used in load testing.</p>"},{"location":"04_test_plan/test_plan/#capsule-server-api-functionality-tests","title":"Capsule server API functionality tests","text":"<p>Server functionality is tested by emulating the end-user client application utilizing the server API interfaces. These tests are run for both ECC and RSA keys. Positive scenarios:</p> <ul> <li>Sender successfully transmits a capsule to the server (<code>[ECC|RSA]-PUT_CAPSULE-POS-01-ONCE</code>)</li> <li>Sender has already transmitted a capsule and is retransmitting the capsule to the server (<code>[ECC|RSA]-PUT_CAPSULE-POS-02-REPEATEDLY</code>)</li> <li>Sender transmits a random byte array not exceeding the defined length to the server as RSA key material (<code>RSA-PUT-CAPSULE-POS-03-RANDOM_CONTENT</code>)</li> <li>Recipients successfully requests a capsule (<code>[ECC|RSA]-GET_CAPSULE-POS-01-CORRECT_REQUEST</code>)</li> <li>Successful transmission of a capsule in a multi-arm system: the capsule is received by one arm and issued by another arm of the system.</li> </ul> <p>Negative scenarios:</p> <ul> <li>Sender transmits an RSA capsule containing overlength key material (<code>RSA-PUT_CAPSULE-NEG-01-CAPSULE_TOO_BIG</code>)</li> <li>Recipient requests a capsule with a random transaction ID (<code>GET_CAPSULE-NEG-02-RANDOM_UUID_TRANSACTION_ID</code>)</li> <li>Recipient requests a capsule with an underlength transaction ID (<code>GET_CAPSULE-NEG-03-TOO_SHORT_TRANSACTION_ID</code>)</li> <li>Recipient requests a capsule with an empty transaction ID (<code>GET_CAPSULE-NEG-04-EMPTY_STRING_TRANSACTION_ID</code>)</li> <li>Recipient requests a capsule with an overlength transaction ID (<code>GET_CAPSULE-NEG-05-TOO_LONG_RANDOM_STRING_TRANSACTION_ID</code>)</li> <li>Recipient requests a capsule with a valid transaction ID but the recipient\u2019s public key does not match the ID (<code>[ECC|RSA]-GET_CAPSULE-NEG-06-PUBLIC_KEY_NOT_MATCHING</code>)</li> </ul>"},{"location":"04_test_plan/test_plan/#server-load-tests","title":"Server load tests","text":"<p>To receive information about the server\u2019s behaviour under stress, the server must be overloaded with queries designed to be as close as possible to the behavioural patterns of real-life users.</p> <p>Depending on the design and functionality of the capsule server, queries made to the server can be divided into two main groups: transmission of capsules to the server, and capsule requests via user authentication. As two different levels of authentication are used on the server, it can be said to essentially comprise two independent web servers with different configurations, sharing a common database for storing key shares.</p> <p>Putting a load on the server requires the use of queries for transmitting key shares to the server and requesting key shares from the server.</p> <ul> <li>In the case of capsule transmission queries, the queries must be functionally successful and result in capsules being saved to the server database.</li> <li>In the case of capsule request queries, the capsule to be used and the user to be authenticated are selected randomly and the reply returned by the server may be either positive (i.e. contain a capsule) or negative (i.e. contain an error code).</li> </ul> <p>The contents of the query are irrelevant for load testing, as the same internal queries and comparisons are required for both positive and negative results.</p>"},{"location":"04_test_plan/test_plan/#load-generation","title":"Load generation","text":"<p>Both the functional tests and the load tests utilize the Gatling test framework where the desired load on the tested software can be adjusted using the following parameters:</p> <ul> <li>start-users-per-second: Number of active users (queries per second) immediately applied at the start of the test</li> <li>increment-users-per-second: Number of active users added per each following test cycle</li> <li>increment-cycles: Number of test cycles used</li> <li>cycle-duration-seconds: Duration of a single test cycle (in seconds)</li> </ul> <p>The duration of a load test depends on the number of test cycles and cycle duration. Number of queries being made to the tested software depends on the initial number of users and the number of users added per each following test cycle. For example, in order to generate a steadily increasing load, the initial number of users can be adjusted to be relatively small, and a larger number of users added per each test cycle.</p> <p>Using the settings below, the duration of the test will be 600 seconds (10 minutes), the initial query rate at the start of the test is 10 queries per second, and the query rate in the last test cycle is 110 queries per second:</p> <ul> <li>start-users-per-second = 10</li> <li>increment-users-per-second = 10</li> <li>increment-cycles = 10</li> <li>cycle-duration-seconds = 60</li> </ul> <p>To generate a steady load, the number of users applied at the start of the test must be adjusted to the desired query rate and the number of users added per test cycle kept minimal.</p> <p>Using the settings below, the duration of the test will be 600 seconds (10 minutes), the initial query rate at the start of the test is 75 queries per second, and the query rate in the last test cycle is 85 queries per second:</p> <ul> <li>start-users-per-second = 10</li> <li>increment-users-per-second = 1</li> <li>increment-cycles = 10</li> <li>cycle-duration-seconds = 60</li> </ul>"},{"location":"04_test_plan/test_plan/#implementation-of-scenarios-in-load-tests","title":"Implementation of scenarios in load tests","text":"<ul> <li>What is the system\u2019s response time to users under different system loads?</li> <li>How many users can the system serve simultaneously without exceeding the defined response time?</li> </ul> <p>Since system operability is directly dependent on the system\u2019s operational environment, answering these questions requires repeatedly running load tests using a variety of loads. To start off, gradually increasing loads can be used to determine potential capacity limits.</p> <ul> <li>How will the system perform under extreme load conditions (e.g. very large number of simultaneous users or key shares in the database)?</li> </ul> <p>The goal of this test is to take the system to or above maximum load and monitor the system\u2019s performance under such conditions. Probing for extreme loads should be carried out using a steady load over a long period of time.</p> <ul> <li>How will the system recover after peak load?</li> </ul> <p>The goal of this test is to gather information on the ability to recover from peak load. Multiple simultaneous load generators can be used here, one performing a longer, steady-load test and the other a shorter, increasing-load test.</p> <ul> <li>How will the system perform under conditions of long-term moderate or higher load?</li> </ul> <p>The system is run for a long period of time under a steady moderate load to detect anomalies or errors that could occur in the long-term operation of the system (small memory leaks etc.). A test involving a steady load of a large number of longer test cycles can be used to seek an answer to this question.</p>"},{"location":"09_Appendixes/A1_Security_level/","title":"Appendix 1 - Security level of password-based encryption/decryption in CDOC2","text":""},{"location":"09_Appendixes/A1_Security_level/#general-regulatory-requirements","title":"General regulatory requirements","text":"<p>Government-issued documents contain some guidance about the required security level. For example, NIST SP 800-57 Part 1, Revision 5 recommends that systems should use at least 128-bit security level and this is adequate for 2030 and beyond (TODO: exact reference). This is applicable, when choosing encryption/decryption algorithms and protocols and in CDOC2 system, AES-128 and similar algorithms are in use.</p> <p>However, when it comes to password-based encryption/decryption, guidelines are not very good. For example, Section 8.1.5.3.8 of NIST SP 800-57 suggests that passwords should provide 128 bits of protection as well. If we would apply this, this would mean that users should use at least 21-character random passwords providing 128 bits of entropy. Also, NIST SP 800-57 doesn't take into account that trying out one password and trying out one AES key takes different amount of time.</p> <p>German BSI document TR-02102-1 (https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/TechGuidelines/TG02102/BSI-TR-02102-1.pdf?__blob=publicationFile) also gives similar guidance:</p> <ol> <li>Section 6.3.1, Remark 6.4 (iii) - \"In other situations where these conditions are not met (for example, when a cryptographic secret is directly derived from the password that provides access to sensitive information), it is recommended to choose passwords via a method that offers at least 120 bits of entropy\"</li> </ol> <p>There's another document SP 800-131 Part 1 - \"Recommendation for Password-Based Key Derivation Part 1: Storage Applications\", which applies specifically to our situation, but the recommendations are not very conclusive:</p> <ol> <li>Annex A.1 - \"For the security of electronically stored data, passwords should be strong enough so that it is infeasible for attackers to gain access by guessing the password\"</li> <li>Annex A.1 - \"Passwords shorter than 10 characters are usually considered to be weak\"</li> <li>Annex A.1 - \"Passphrases shorter than 20 characters are usually considered weak\"</li> </ol>"},{"location":"09_Appendixes/A1_Security_level/#pbkdf2-regulatory-requirements","title":"PBKDF2 regulatory requirements","text":"<p>NIST SP 800-131 Part 1 gives following recommendation:</p> <ol> <li>Annex A.2.2 - \"The number of iterations should be set as high as can be tolerated for the environment, while maintaining acceptable performance.\"</li> </ol> <p>German TR-02102-1 gives following recommendation (while suggesting to use Argon2id in place of PBKDF2)</p> <ol> <li>Section B.1.3 - \"The security parameters of Argon2id and the requirements for the passwords depend on the application scenario and should be discussed with an expert\"</li> </ol> <p>Taking into account the NIST recommendation and based on tests on general purpose CPU (Apple M2 3.49 GHz), it takes around 1-2 seconds to run PBKDF2 algorithm with 10,000,000 (\\(1 \\cdot 10^7\\)) iterations. This seems to be reasonable performance tradeoff.</p>"},{"location":"09_Appendixes/A1_Security_level/#modeling-attacker-capabilities","title":"Modeling attacker capabilities","text":"<p>When we consider brute-force exhaustive password search attack against CDOC2 Container, we have to somehow model the capabilities of the attacker. It is especially difficult, because we have to consider a long crypto-period. Attacker may store the captured CDOC2 Container and launch the attack after powerful computers have emerged, or execute the attack for longer period of time, like multiple years.</p> <p>\"Bovine RC5 effort\" (https://www.distributed.net/RC5) is one of the examples of highly parallel exhaustive key searches performed in 2002. They were able to find 64-bit encryption key for RC5 ciphertext within 1,757 days, by using computers of 331,252 individuals. Massive parallel exhaustive search is therefore certainly within capabilities of attackers.</p> <p>There are no guidelines for estimating, how many CPU cores an attacker might be able to use. We could use an estimate for the upper bound, by taking the number of CPU cores in the world. ARM company has estimated that all their partners combined, have shipped more than 25 billion (\\(\\approx 2.5 \\cdot 10^{10}\\)) chips in year 2020 (https://newsroom.arm.com/news/arm-partners-are-shipping-more-than-900-arm-based-chips-per-second-based-on-latest-results). We could assume that all of those chips are controlled by single attacker and all of those chips are capable of doing a PBKDF2 operation with \\(1 \\cdot 10^7\\) iterations in one second. Then we could have our upper bound for a very powerful attacker, which is \\(\\approx 7.8 \\cdot 10^{17}\\) password tries per year.</p> <p>TODO: Another way to validate this upper bound, is to compare this with bitcoin mining performance, because PBKDF2() operation is essentially doing SHA-256 hash computations. We could assume that attacker is controlling the whole bitcoin mining infrastructure and could arrive another upper bound.</p>"},{"location":"09_Appendixes/A1_Security_level/#cdoc2-password-length-requirements","title":"CDOC2 password length requirements","text":"<p>One example of practical passwords, which are considered secure, are Apple's \"Automatic strong passwords\" (https://support.apple.com/en-gb/guide/security/secc84c811c4/web). They are 20 characters long, contain one digit, one uppercase, two hyphens and 16 lowercase characters. Such generated passwords contain 71 bits of entropy.</p> <p>If CDOC2 system would enforce using similar passwords and would use PBKDF2 with \\(1 \\cdot 10^7\\) iterations, it would mean that our hypothetical attacker could try out all combinations ( \\(2^{71} \\approx 2.3 \\cdot 10^{21}\\) ) within</p> \\[ \\frac{2.3 \\cdot 10^{21}}{7.8 \\cdot 10^{17}} \\approx 3000 \\] <p>years. Taking into account that we modeled our upper bound for our attacker, these kinds of 71-bit entropy passwords should provide us multiple orders of magnitude for a security margin.</p>"},{"location":"09_Appendixes/A1_Security_level/#notes-down-below","title":"Notes down below","text":""},{"location":"09_Appendixes/A1_Security_level/#cdoc2-security-level","title":"CDOC2 security level","text":"<p>Plan:</p> <ol> <li>There are no strict requirements for password length, when PBKDF2 is used for AES128 encryption keys.</li> <li>But there are some heuristics-based guidelines.</li> <li>\"In 2023, OWASP recommended to use 600,000 iterations for PBKDF2-HMAC-SHA256 and 210,000 for PBKDF2-HMAC-SHA512.[6]\"</li> <li>Also, when we use maximal reasonable iteration count, then we allow the attacker to have about 1 PBKDF2 try per second.</li> <li>Assuming that SHA-256 is safe</li> <li>Assuming in safety margin. 10 fold? million fold?</li> <li>Then we can let users use X-character passwords</li> </ol> <p>Safety margin:</p> <p>https://crypto.stackexchange.com/questions/68672/origin-of-values-for-security-margin https://eprint.iacr.org/2017/560.pdf https://www.cryptopp.com/wiki/Security_Level</p> <p>distributed.net was able to find RC5-64 key within 1,757 days. So, they broke 64-bit entropy password. They were able to do 2^64 = 18446744073709551616 = 10^19 tries.</p> <p>10^19/(17572460*60) = 10^10 tries per second</p> <p>They used 331 000 individuals. Assuming that attackers nowadays are able to utilise every computer in the world. (https://newsroom.arm.com/news/arm-partners-are-shipping-more-than-900-arm-based-chips-per-second-based-on-latest-results)</p> <p>70 million chips a day -&gt; 2*10^10 chips per year.</p> <p>Assuming that attacker is able to use all of such chips and is able to parallelise PBKDF computations.</p>"},{"location":"09_Appendixes/A1_Security_level/#password-length","title":"Password length","text":"<p>CDOC2 system security model is based on 128-bit security level (https://en.wikipedia.org/wiki/Security_level). For example, AES encryption implemented inside CDOC2 system uses 128-bit keys, which translates to 128-bit security level. There are lot of assumptions and estimations and safety margins included here, but the general consensus is that 128-bit security level provides adequate protection beyond 2030.</p> <p>https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf</p> <p>\"SP 800-57, Part 1 also provides guidance about protecting information past 2030. Section 5.6.4 of that document advises selecting algorithms and key sizes that are expected to be secure for the entire security life of the protected data. This is particularly important when nearing algorithm transition dates. For example, if the data to be encrypted has a security life of 15 years, then protection at a security strength of 112 bits will not be sufficient, since the 15-year period extends beyond 2030.\"</p> <p>Password length recommendations are based on the same assumption, that it shouldn't be easier to brute-force passwords used in the password-based encryption/decryption scheme (TODO: link to scheme).</p> <p>TODO: However, brute-forcing a 128-bit AES key would take more energy and more time than lifetime of multiple universes (TODO: link) So, does it make sense to have this high bar?</p> <p>Brute-forcing passwords is possible when attacker tries all possible password combinations.</p> <p>Example: We know that user have to use a 20 character password, from the set of case sensitive alphanumeric (a\u2013z, A\u2013Z, 0\u20139) characters. This translates to roughly 5.9 bits per character. Times 20, gives 118 bits of entropy.</p> <p>That means that attacker has to try out \\(2^118\\) combinations. Which is too much anyway.</p> <p>Is it ok, if we lower the bar to 100 years?</p> <p>https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf</p> <p>\"Passphrases shorter than 20 characters are usually considered weak.\" \"Passwords shorter than 10 characters are usually considered to be weak.\"</p> <p>\"iteration count of 10,000,000 may be appropriate.\" \"The number of iterations should be set as high as can be tolerated for the environment, while maintaining acceptable performance.\"</p> <p>1 second for generation?</p> <p>10 characters, capital, numbers, 5.9 bits of entropy per character.</p> <p>\\(10*5.9 = 59\\)</p> <p>\\(2^59 = 576460752303423488 = 5*10^17\\)</p> <p>Age of universe is 13 billion years = 13 * 10^9 years * 365246060 =  410^17 seconds</p> <p>$ (510^17) / (210^10) = 2.5*10^7 seconds</p> <p>3.1*10^7 seconds in a year</p> <p>So .. 10 character password with ~60 bits of entropy, with 1 second PBKDF iterations, could be found by utilising all ARM cores shipped within one year in a whole world, by running all of them for 1 year.</p> <p>Fine, let's do 20 characters, like Apple offers, and lets use 71 bits of entropy.</p> <p>\\(2^71 = 2361183241434822606848 = 2.3 * 10^21\\)</p> <p>20 character password, with ~71 bits of entropy, could be found by utilising all ARM cores shipped within one year in a whole world, by running all of them for 3700 years.</p> <p>$ (2.3 * 10^21) / (210^10) / (3.110^7) = 3700$ years.</p> <p>This should be good, we have safety margin of 1000 times. Even if the attacker is able to do PBKDF thousand times quicker, it still takes them all the ARM cores and a year.</p> <p>BSI Technical Guideline \u2013 Cryptographic Algorithms and Key Lengths</p> <p>\"In other situations where these conditions are not met (for example, when a cryptographic secret is directly derived from the password that provides access to sensitive information), it is recommended to choose passwords via a method that offers at least 120 bits of entropy.\"</p> <p>https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/Publications/TechGuidelines/TG02102/BSI-TR-02102-1.pdf?__blob=publicationFile</p> <p>\"9. SecretSharing\"</p> <p>https://www.theregister.com/2009/08/03/new_crypto_attack/</p> <p>https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography</p>"},{"location":"09_Appendixes/A2_integration_with_password_managers/","title":"Appendix 2 - Integration with Password Managers","text":""},{"location":"09_Appendixes/A2_integration_with_password_managers/#intro","title":"Intro","text":"<p>Users regularly use passwords managers, either embedded into the browsers or separate applications, to manage and protect passwords that they need to enter into various web pages or applications. When CDOC2 System implements password-based encryption schemes, it becomes interesting question, if and how passwords managers could be used to simplify some of tasks, such as password generation, storing, and password entering.</p>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#password-managers","title":"Password managers","text":"<p>This analysis covers following types of password managers.</p> <p>Operating system integrated password managers:</p> <ol> <li>Windows Credential Manager (https://support.microsoft.com/en-us/windows/accessing-credential-manager-1b5c916a-6a16-889f-8581-fc16e8165ac0)</li> <li>MacOS/IOS KeyChain with iCloud KeyCloud syncing and backup service (https://support.apple.com/en-us/109016)</li> </ol> <p>Browser integrated password managers:</p> <ol> <li>Google Password Manager for Chrome (https://passwords.google.com/)</li> <li>Mozilla Password Manager for Firefox (https://www.mozilla.org/en-US/firefox/features/password-manager/)</li> </ol> <p>Third party (commercial) applications and services:</p> <ol> <li>Bitwarden (https://bitwarden.com)</li> <li>1Password (https://1password.com)</li> <li>LastPass (https://lastpass.com)</li> </ol> <p>Open-source password managers:</p> <ol> <li>KeePassXC (https://keepassxc.org)</li> </ol>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#no-security-assessment","title":"No security assessment","text":"<p>Current analysis only looks at integration possibilities, from simply technical viewpoint, and doesn't assess the quality or trustworthiness of particular passwords managers in any other way. For example, there's no assessment, how specific password manager application stores passwords in a local database, whether they are encrypted with some sort of master password or not.</p> <p>Also, whether user should trust a commercial cloud-based password manager or synchronization services or any other software, depends on the attack model and risk tolerance of the particular user.</p>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#overview-of-integration-possibilities","title":"Overview of integration possibilities","text":""},{"location":"09_Appendixes/A2_integration_with_password_managers/#manual-copy-paste","title":"Manual copy-paste","text":"<p>The most basic level of integration possibility is that user does perform all tasks manually by using clipboard function for copy-pasting passwords between CDOC2 Client application and password manager. This has added benefit that password manager could be both native application or website. Downside is the additional work that user needs to do.</p>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#hot-key-based-auto-fill","title":"Hot-key-based auto-fill","text":"<p>KeePassXC has interesting integration option called \"Auto-Type\" (https://keepassxc.org/docs/KeePassXC_UserGuide#_auto_type). It works this way that KeePassXC application listens for a unique hot-key combination and then depending on the title of the application in focus (\"Notepad\", \"DigiDoc4 Client\"), KeePassXC searches for a matching password entry and sends a configurable sequence (for example, \"username\", TAB, \"password\", ENTER) to that application. Optionally, user can preview and confirm this action, before KeePassXC actually sends passwords to other windows.</p> <p>Actual usage of this feature is not so simple, because window titles tend to include the opened filename as well, and KeePassXC doesn't support regular expressions. However, this might be something to keep in mind.</p>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#cli-based-programmatic-integration","title":"CLI-based programmatic integration","text":"<p>Some password managers also offer separate CLI application, which could be invoked from shell scripts and could be used to integrate password manager services into various places, for example, CI/CD actions.</p>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#list-of-cli-applications","title":"List of CLI applications","text":"Password Manager CLI application name References Windows Credential Manager <code>cmdkey.exe</code><code>vaultcmd.exe</code> Windows Server manual page for <code>cmdkey</code> Hacker recipes - Windows Credential Manager MacOS/IOS KeyChain <code>security</code> Blog post with examples, man page for <code>security</code> Google Password Manager no official options Mozilla Password Manager no official options Bitwarden <code>bw</code> https://bitwarden.com/help/cli/ 1Password <code>op</code> https://developer.1password.com/docs/cli LastPass <code>lastpass-cli</code> https://github.com/lastpass/lastpass-cli KeePassXC <code>keepassxc-cli</code> Section in User Manual, man page for <code>keepassxc-cli</code>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#cli-api-methods","title":"CLI API methods","text":"<p>All CLI application offer adequate collection of methods for shell script integration, such as adding new password entries, searching, reading password entries, and deleting password entries.</p>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#access-authentication","title":"Access authentication","text":"<p>When another application runs the CLI application and asks for an access to stored password entry inside password manager database, the access call must be somehow authenticated, to make sure that potentially malicious applications, which are running under the privileges of the same user, cannot have access to passwords.</p> <p>There are following authentication options:</p> <ol> <li>Password-based authentication, where you supply your username and password to CDOC2 Client application. Essentially, Client application gains the same privileges as the original user.</li> <li>\"API key\"-style authentication, where you create an independent software token and supply this to CDOC2 Client application.</li> <li>MacOS KeyChain supports application name-based authentication, where you specify the path to the application binary, which is requesting access.</li> </ol>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#fine-grained-authorization","title":"Fine-grained authorization","text":"<p>In case user has other passwords in the password manager database, in addition to passwords of various CDOC2 Containers, the question of allowing access to only a subset of password becomes important. It could be solved with following options:</p> <ol> <li>Only store passwords for CDOC2 Containers in that particular password manager, which is integrated with CDOC2 Client application.</li> <li>Create a separate \"vault\" or \"collection of passwords\", in case password manager supports this, and only allow CDOC2 Client application access to this particular \"vault\".</li> <li>Add fine-grained ACLs to each password entry.</li> </ol>"},{"location":"09_Appendixes/A2_integration_with_password_managers/#programmatic-or-rest-api-integration","title":"Programmatic or REST API integration","text":""},{"location":"09_Appendixes/A2_integration_with_password_managers/#list-of-apis","title":"List of APIs","text":"Password Manager API references Windows Credential Manager Win32 API WinCred.h MacOS/IOS KeyChain KeyChain Services, Keychain items, TN3137: On Mac keychain APIs and implementations Bitwarden Vault Management REST API 1Password 1Password Connect REST API KeePassXC Linux FreeDesktop Secret Service API"},{"location":"09_Appendixes/A2_integration_with_password_managers/#summary","title":"Summary","text":"<p>This analysis reviewed how popular password managers on MacOS and Microsoft Windows operating systems could be integrated with the CODC2 Client Application. There is not a clearly superior integration option suitable for all users. CLI-based integration options could be superior for organizations who integrate container encryption into their information systems or other workflows. However, access authorization and having the authorization be fine-grained become important decisions which probably each organization has to tackle individually as it depends on the choice of password managers and information security policies. The manual copy-paste solution is probably the most realistic option for individuals who use the Client Application less frequently and not as part of an information system workflow and should problably be the suggested method.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/","title":"Appendix 3 - Yubikey integration","text":""},{"location":"09_Appendixes/A3_YubiKey_integration/#introduction","title":"Introduction","text":"<p>Yubico offers several security tokens (https://www.yubico.com/products/) with convenient wired interfaces (USB-A, Apple Lightning, USB-C) and wireless interfaces (Bluetooth, NFC) which makes them viable alternative to smart-cards or other USB security tokens. Smart-cards usually require additional USB card-readers, which is inconvenient. Other USB key tokens (for example, SafeNet eToken 5110) could be more expensive (https://portal.skidsolutions.eu/order/certificates?tab=crypto-stick). This chapter analyses the APIs provided by Yubico products and discusses, how these could be used by CDOC2 Client Applications.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#yubico-security-tokens","title":"Yubico security tokens","text":"<p>Yubico provides following general family of products:</p> <ol> <li>YubiKey 5 series (https://support.yubico.com/hc/en-us/articles/360016649339-YubiKey-5C-NFC)</li> <li>YubiKey Bio series (https://support.yubico.com/hc/en-us/articles/4407743521810-YubiKey-Bio-FIDO-Edition)</li> <li>Security key series (https://support.yubico.com/hc/en-us/articles/360013779399-Security-Key-NFC)</li> </ol> <p>and some HSM families and legacy products, which are not included in current analysis.</p> <p>In summary, these security tokens offer the following types of APIs/interfaces or support these kinds of hosted credentials:</p> <ol> <li>Secure Static Passwords</li> <li>FIDO U2F interface</li> <li>FIDO2 CTAP1/CTAP2 interface and WebAuthn credentials (hardware-bound passkeys)</li> <li>OATH credentials (OATH-TOTP, OATH-HOTP) and Yubico OTP credentials</li> <li>NIST SP 800-73 (PIV) compliant smart-card interface</li> <li>OpenPGP Smart Card</li> </ol> <p>The following sections discuss the possibilities of those interfaces/credentials.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#interfacing-options","title":"Interfacing options","text":""},{"location":"09_Appendixes/A3_YubiKey_integration/#secure-static-passwords","title":"Secure Static Passwords","text":"<p>\"Secure Static Passwords\" feature is compatible with YubiKey 5 series and not compatible with Security Key and YubiKey Bio.</p> <p>YubiKey USB token can be programmed by YubiKey Manager application (https://docs.yubico.com/software/yubikey/tools/ykman/) to store a randomly generated static password. USB token can act as a virtual USB keyboard and can send the password to the computer, when user presses the physical button on the token. This results in the same effect as the user himself would have entered the password on the physical keyboard. (https://support.yubico.com/hc/en-us/articles/360016614980-Understanding-Core-Static-Password-Features, https://resources.yubico.com/53ZDUYE6/as/9hccqgx9bwwqq96mhkk8jb4h/Static_Password_Function.pdf).</p> <p>Unfortunately, YubiKey USB token can only hold one such password. Even though, CDOC2 Client integration with this feature could be very easy, using the same password for all CDOC2 Containers wouldn't be advisable. The popular use-case for this feature is to secure the master password of the password manager application, and then let the password manager handle all the individual passwords for other websites and applications.</p> <p>Therefore, directly using the \"Secure Static Passwords\" feature by CDOC2 Clients is not recommended and this integration feature is not analyzed further.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#fido-u2f-interface","title":"FIDO U2F interface","text":"<p>This feature is compatible with all YubiKey security tokens.</p> <p>FIDO U2F is an open standard (https://fidoalliance.org/specs/fido-uaf-v1.2-ps-20201020/fido-uaf-overview-v1.2-ps-20201020.html, https://developers.yubico.com/U2F/), which allows computer and mobile applications to communicate with internal or external authenticators (e.g. YubiKey tokens) and to use challenge-response authentication flow, based on PKI cryptography. The U2F authenticator has a private key and can sign messages with the private key. Authenticators support using unique key pairs for each application and they can also issue device attestations.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#fido-u2f-signature-capabilities","title":"FIDO U2F signature capabilities","text":"<p>Unfortunately, the cryptographic API only supports creating signatures (RS256, EdDSA, ES256, and Ed25519, https://developers.yubico.com/WebAuthn/WebAuthn_Developer_Guide/Algorithms.html) and no key agreement protocols. This means that Yubico security tokens are facing the same issue as Mobil-ID/Smart-ID eID schemes, which can also provide only signature creation and could be only used for authentication. However, at the same time Mobile-ID/Smart-ID eID schemes also provide subscriber identity management, by following strict identity proofing and registration procedures and issuing X.509 certificates, which bind together subscriber's identity and subscriber's key pair information.</p> <p>It could be possible to integrate FIDO U2F compliant security tokens into the CDOC2 System by additionally implementing user's account management as well. A user would need to authenticate to CDOC2 self-service portal with existing strong eID means (ID-card, Mobile-ID, Smart-ID) and associate FIDO U2F compliant security token with their account, by registering the public key of a new key pair. This would enable CDOC2 Capsule Servers to use FIDO U2F tokens for authenticating the user and allowing the user to download capsules. It would be recommended for the user to register multiple FIDO tokens, in order to have redundancy.</p> <p>CDOC2 Client Application could handle such registration by using the operating system's browser to open the CDOC2 System's self-service portal and authentication portal web sites and because browsers are already integrated with FIDO U2F tokens (and WebAuthn and passkeys), the integration would work out-of-box.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#reusing-rsa-signing-for-encryptiondecryption","title":"Reusing RSA signing for encryption/decryption","text":"<p>FIDO U2F specification also supports <code>ALG_SIGN_RSASSA_PSS_SHA256_RAW</code> and <code>ALG_SIGN_RSA_EMSA_PKCS1_SHA256_RAW</code> signatures (https://fidoalliance.org/specs/fido-v2.0-id-20180227/fido-registry-v2.0-id-20180227.html#authentication-algorithms). The availability of unpadded (raw) signatures hints at the possibility that perhaps, YubiKey tokens could be also used for RSA encryption/decryption operation.</p> <p>From cryptography viewpoint, it might be possible, because internally, the YubiKey token is performing <code>RSASP1()</code> operation (https://datatracker.ietf.org/doc/html/rfc8017#section-5.2.1), which is exactly the same operation as <code>RSAEP()</code> operation (https://datatracker.ietf.org/doc/html/rfc8017#section-5.1.1). However, this needs to be experimentally verified.</p> <p>From CDOC2 System viewpoint, there is still the problem of how the Sender gets information about authentic RSA public key of the Recipient, so that Sender could use the CDOC2 SC02 encryption scheme. Because there's no X.509 certificates and no identity management services within FIDO, this is unresolved. Building custom PKI services into the CDOC2 System, which would work on top of FIDO U2F tokens, seems unrealistic.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#fido-ctap2-interface-and-webauthn-credentials","title":"FIDO CTAP2 interface and WebAuthn credentials","text":"<p>This feature is compatible with all YubiKey security tokens.</p> <p>FIDO CTAP1 interface provides same features as FIDO U2F interface, using APDU-like binary structure for transmitting messages between computer and authenticators.</p> <p>FIDO CTAP2 interface (https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html) provides FIDO CTAP1 interface features and some extra, while also using CBOR encoding for transmitting the messages between computer and authenticators.</p> <p>WebAuthn2 standard (https://www.w3.org/TR/webauthn-2/) provides JavaScript API for web sites running inside browser, in order to use FIDO authenticators, over U2F, CTAP1, or CTAP2 interfaces.</p> <p>Security tokens, which comply with WebAuthn2 and CTAP2, could be also referred as FIDO2 tokens. At the moment, YubiKey 5 Series tokens can hold up to 25 resident keys (also called discoverable credentials).</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#fido-ctap2-signature-capabilities","title":"FIDO CTAP2 signature capabilities","text":"<p>In the same way as U2F, CTAP2 provides assertion signature creation function <code>authenticatorGetAssertion (0x02)</code> (https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#authenticatorGetAssertion, https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion). Therefore, all the considerations, that were discussed in previous section \"FIDO U2F signature capabilities\", also apply to CTAP2.</p> <p>However, CTAP2 also has some extensions (https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#sctn-defined-extensions), which we look into at next sections.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#credblob-and-largeblobkey-extensions","title":"<code>credBlob</code> and <code>largeBlobKey</code> extensions","text":"<p><code>credBlob</code> extension (https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#sctn-credBlob-extension) allows some secret information (a blob array) to be stored inside FIDO2 token, alongside the RP-specific credential. Optionally, computer could request that FIDO2 token performs the user authorization (i.e., asks the user to press the physical button on the FIDO2 token) or performs the verification of the supplied PIN-code, when retrieving this array.</p> <p>This blob could be used as a place to store the symmetric encryption/decryption key of the CDOC2 Container. Unfortunately, YubiKey 5 Series tokens only support (https://docs.yubico.com/hardware/yubikey/yk-tech-manual/yk5-apps.html#supported-extensions) <code>appID</code> extension (https://www.w3.org/TR/webauthn-2/#sctn-appid-extension).</p> <p>It's not know, if any FIDO2 tokens on the market support these extensions. They are not listed as mandatory features (https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#mandatory-features) of CTAP2 standard.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#hmac-secret-extension","title":"<code>hmac-secret</code> extension","text":"<p>This extension is used by the computer to retrieve a symmetric secret from the authenticator when it needs to encrypt or decrypt data using that symmetric secret (https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#sctn-hmac-secret-extension).</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#using-hmac-secret-from-computer-applications","title":"Using HMAC Secret from computer applications","text":"<p>In order to create such a FIDO2 credential, which can be used to derive a CDOC2 Container symmetric encryption key, following steps should be done:</p> <ol> <li>Computer chooses user validation protocol (https://fidoalliance.org/specs/fido-v2.1-ps-20210615/fido-client-to-authenticator-protocol-v2.1-ps-errata-20220621.html#authenticatorClientPIN), which is based on user's PIN code, or on-device user verification method like fingerprint or input UI with secure communication.</li> <li>Computer sends <code>authenticatorClientPIN (0x06)</code> command with parameters <code>pinUvAuthProtocol</code> and <code>getKeyAgreement(0x02)</code> and establishes a shared secret with the authenticator.</li> <li>Computer sends <code>authenticatorMakeCredential (0x01)</code> command with parameters <code>\"hmac-secret\": true</code></li> <li>Authenticator generates two random 32-byte values (called <code>CredRandomWithUV</code> and <code>CredRandomWithoutUV</code>) and associates them with the freshly created FIDO2 credential and sends back to the computer the key handle, with parameters <code>\"hmac-secret\": true</code>.</li> <li>Computer should store the handle to FIDO2 credential and other required parameters.</li> </ol> <p>In order to retrieve the key material for symmetric encryption key, the computer should do following steps:</p> <ol> <li>Computer sends <code>authenticatorClientPIN (0x06)</code> command with parameters <code>pinUvAuthProtocol</code> and <code>getKeyAgreement(0x02)</code> and establishes a shared secret with the authenticator.</li> <li>Computer sends <code>authenticatorGetAssertion (0x02)</code> command with extension map <code>hmac-secret</code> and parameters <code>salt1</code>, protecting the arguments with the shared secret established in the previous step.</li> <li>Authenticator verifies the command parameters, chooses <code>CredRandom=CredRandomWithUV</code> and responds with <code>output1=HMAC-SHA-256(CredRandomWithUV, salt1)</code> and returns <code>output1</code>, protecting the data with shared secret established in the previous step.</li> <li>Computer can use <code>output1</code> or <code>output2</code> as the key material for CDOC2 encryption scheme SC05.</li> </ol> <p>An example of some open-source implementations, who are using this feature, could be found at</p> <ul> <li>https://github.com/FiloSottile/age/discussions/390 and https://github.com/olastor/age-plugin-fido2-hmac/blob/main/SPEC.md</li> <li>https://github.com/keepassxreboot/keepassxc/issues/3560</li> </ul>"},{"location":"09_Appendixes/A3_YubiKey_integration/#prf-feature-in-webauthn3","title":"PRF feature in WebAuthn3","text":"<p>The usage of HMAC Secret Extension is further improved in the upcoming WebAuthn version 3 standard (https://w3c.github.io/webauthn/#prf-extension). This allows websites to request PRF (pseudo-random function) outputs, that could be used as symmetric keys to encrypt user data. Internally, the browser would be talking to FIDO2 authenticator and would be using the same HMAC Secret Extension to obtain symmetric keys.</p> <p>This should indicate that CTAP2 protocol extension <code>hmac-secret</code> is probably not going away.</p> <p>Some further information is provided in:</p> <ul> <li>https://forums.developer.apple.com/forums/thread/733413</li> <li>https://bitwarden.com/blog/prf-webauthn-and-its-role-in-passkeys</li> <li>https://github.com/w3c/webauthn/wiki/Explainer:-PRF-extension</li> </ul>"},{"location":"09_Appendixes/A3_YubiKey_integration/#passkeys","title":"Passkeys","text":"<p>It's not clear, if browsers and operating systems, which have built-in support for passkeys (which are kind of FIDO2 authenticators) also support such extensions. Some information available at https://github.com/w3c/webauthn/issues/1830 and https://chromestatus.com/feature/5138422207348736 seem to hint that Android 13 and Chrome Canary might support this already.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#oath-credentials","title":"OATH credentials","text":"<p>OATH API feature is compatible with YubiKey 5 series security tokens and not compatible with YubiKey Security Key and YubiKey Bio series.</p> <p>OATH is a consortium (https://openauthentication.org/about-oath/), which is standardizing authenticators and also one-time-password methods, such as time-based one-time password (TOTP) and HMAC-based one-time password (HOTP).</p> <p>It turns out that it is possible to use HOTP, also published as https://www.rfc-editor.org/rfc/rfc4226.html, as a decryption key provider. This has been described in https://support.yubico.com/hc/en-us/articles/360013779759-Using-Your-YubiKey-with-KeePass and (experimentally) implemented in KeepPassXC plugin KeeChallenge (https://brush701.github.io/keechallenge/).</p> <p>Since this seems to be a non-standard way of using an authentication protocol for encryption/decryption. It's not clear, what kind of vulnerabilities or risks this method may have. We do not recommend to further analyze this feature.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#smart-card-api","title":"Smart-card API","text":"<p>Smart-card API feature is compatible with YubiKey 5 series security tokens and not compatible with YubiKey Security Key and YubiKey Bio series.</p> <p>Smart-card API allows to perform RSA or ECC sign/decrypt operations using a private key stored on YubiKey tokens. RSA 1024, RSA 2048, or ECC secp256r1 keys are supported. YubiKey 5 can hold up to 24 key pairs and certificates.</p> <p>In a sense, with this API, YubiKey security token becomes a regular smart-card, comparable to ID-card, but YubiKey is directly usable over USB interfaces and also over contact-less interfaces. From a cryptography viewpoint, such tokens could be used to in CDOC2 encryption schemes SC01, SC02, SCO3, SC04. However, because YubiKey tokens are not integrated with identity management function of ID-card eID scheme, there's no easy way for Senders to find out, what are the correct key pairs of intended Recipients.</p> <p>Another possibility is to use YubiKey hosted EC key pair for ECDH shared key establishment and to use this derived key as encryption/decryption key for the local storage of CDOC2 Container. Perhaps it could be done in a similar way as NIST SP 800-73-4 Part 2, Section 4.2 is establishing (https://csrc.nist.gov/files/pubs/sp/800/73/4/final/docs/sp800_73-4_pt2_revised_draft.pdf) secrets for secure messaging, or in a similar way as ECIES scheme is establishing secrets for encryption/decryption (https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme). CDOC2 currently doesn't have such a crypto scheme defined, it would need to be an addition to existing storage-crypto schemes SC05 and SC06.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#openpgp-smart-card-api","title":"OpenPGP Smart Card API","text":"<p>Not analyzed currently. Assuming this is similar to NIST PIV-compliant smart-card API.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#security-aspects","title":"Security aspects","text":""},{"location":"09_Appendixes/A3_YubiKey_integration/#identity-management","title":"Identity management","text":"<p>In case FIDO token is used as simple authenticator, CDOC2 system has to maintain associations between national identity codes and FIDO public key pairs. This database and self-service management portal then becomes a lucrative single point for attacks and has to be protected as a trusted system component, because if attacker is able to add their own FIDO public key to the user's account, they are able to authenticate to Capsule Servers and retrieve the key material for decrypting the CDOC2 Container on behalf of the user.</p> <p>In that sense, the identity proofing and identity management functions of those eID schemes, which are supported by CDOC2 System, are really critical.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#encryption-key-inside-application-memory","title":"Encryption key inside application memory","text":"<p>In case FIDO token is used as symmetric encryption key provider, the encryption key is transferred to CDOC2 Client Application process memory and is processed on the computer CPU. The presents an opportunity to leak the key and this may feel risky, when compared to the usual practices of using HSM-bound crypto material.</p> <p>It might be interesting to compare the security level of YubiKey hosted encryption key and ordinary USB memory stick, which hosts wrapped encryption key, protected with user's PIN or password. In both cases, the encryption key is transferred to the application memory and processed there, in the clear text. However, YubiKey provides better protection against offline brute-force attacks, in case the PIN-code or password, which is used to derive the unwrapping key, is rather short. For example, if we use a very expensive key derivation function, which takes 5 minutes to derive unwrapping key, the attacker could still simply try all 4-digit PIN-codes in about a month time and successfully retrieve the unwrapping key.</p>"},{"location":"09_Appendixes/A3_YubiKey_integration/#summary","title":"Summary","text":"<p>There are multiple ways to continue:</p> <ol> <li>Use YubiKey security token (or any other compliant security token) as authenticator for accessing CDOC2 Capsule Servers. This could be achieved by using FIDO U2F compliant interface or by using smart-card compatible interface.</li> <li>Use YubiKey security token (or any other FIDO2 compatible token, including passkey implementations, which supports <code>hmac-secret</code> extension) as symmetric encryption/decryption key provider for long-term storage crypto. This could complement password-based encryption schemes in CDOC2 System.</li> <li>Use YubiKey security token (or any other smart-card compatible token) as a symmetric encryption key provider, based on EC key pair and ECDH key establishment protocols, for long-term storage crypto. This could add to password-based encryption schemes in CDOC2 System.</li> </ol> <p>Current recommendation is to further study the options 2 and 3 and to work out approximate estimates for integration and development efforts. As option 2 is also supported by Security Key Series, which are somewhat cheaper than YubiKey 5 series (https://www.yubico.com/ee/store/compare/), the priority should be on option 2.</p>"}]}